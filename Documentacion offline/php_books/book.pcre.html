<div id="book.pcre" class="book"><hr>
 
 <h1 class="title">Expresiones regulares (compatibles con Perl)</h1>
 

 <div id="intro.pcre" class="preface"><hr>
  <h1 class="title">Introducción</h1>
  <p class="para">
   La sintaxis de los patrones utilizados en estas funciones se asemeja
   mucho a la de Perl. Las expresiones estarán rodeadas
   de delimitadores, como la barra (/), por ejemplo. Un delimitador puede
   ser cualquier carácter, siempre que no sea alfanumérico, un carácter blanco,
   la barra invertida (\) o el carácter nulo (\0).
   Si un delimitador debe ser utilizado en
   la expresión, deberá protegerse con una barra invertida.
   Los delimitadores a la Perl (), {}, [], y &lt;&gt; también pueden ser utilizados.
   Consulte la <a href="#reference.pcre.pattern.syntax" class="link">sintaxis de los patrones</a>
   para más explicaciones.
  </p>
  <p class="para">
   El delimitador final puede ser seguido de opciones que
   afectarán la búsqueda. Consulte también
   <a href="#reference.pcre.pattern.modifiers" class="link">opciones de búsqueda</a>.
  </p>
  <blockquote class="note"><p><strong class="note">Nota</strong>: 
   </p><p class="para">
    Esta extensión mantiene un caché global por hilo de las expresiones
    regulares compiladas (hasta 4096).
   </p>
  </blockquote>
  <div class="warning"><strong class="warning">Advertencia</strong>
   <p class="para">
    Deben tenerse en cuenta las limitaciones de PCRE.
    Consulte <a href="http://www.pcre.org/pcre.txt" class="link external">» http://www.pcre.org/pcre.txt</a> para más detalles.
   </p>
  </div>
  
  <p class="para">
   La biblioteca PCRE es un conjunto de funciones que implementan las
   expresiones regulares utilizando la misma sintaxis y semántica
   que Perl 5 con solo algunas diferencias (ver más abajo). La implementación
   actual corresponde a Perl 5.005.
  </p>
 </div>
<hr>


 




<div id="pcre.setup" class="chapter"><hr>
 <h1 class="title">Instalación/Configuración</h1>
<h2>Tabla de contenidos</h2><ul class="chunklist chunklist_chapter"><li><a href="#pcre.installation">Instalación</a></li><li><a href="#pcre.configuration">Configuración en tiempo de ejecución</a></li></ul>


 




<div id="pcre.installation" class="section"><hr>
 <h2 class="title">Instalación</h2>
 <p class="para">
  La extensión PCRE es una extensión nativa de PHP, por lo que siempre está
  activada. Por omisión, esta extensión se compila utilizando la
  biblioteca PCRE empaquetada. Opcionalmente, puede utilizarse una
  biblioteca PCRE externa pasando la opción de configuración
  <strong class="option configure">--with-pcre-regex=DIR</strong> donde
  <code class="literal">DIR</code> es la ruta de acceso a los ficheros de la biblioteca PCRE.
  Se recomienda utilizar PCRE 8.10 o más reciente;
  a partir de PHP 7.3.0, PCRE2 es requerido.
 </p>
 <p class="para">
  La compilación Just In Time (JIT) de PCRE es soportada por omisión,
  pudiendo ser desactivada con la opción de configuración
  <strong class="option configure">--without-pcre-jit</strong> a partir de PHP 7.0.12.
 </p>
 <p class="simpara">La versión Windows de PHP
dispone del soporte automático de esta extensión. No es necesario
añadir ninguna biblioteca adicional para disponer de estas funciones.</p>
 <p class="para">
  PCRE es un proyecto activo y a medida que cambia, las
  funcionalidades de PHP también lo hacen. Es posible que algunas
  partes del manual de PHP estén obsoletas y no cubran
  las nuevas funcionalidades proporcionadas por PCRE. Para una lista de
  modificaciones, consúltese el
  <a href="http://www.pcre.org/original/changelog.txt" class="link external">» registro de cambios de la biblioteca PCRE</a>
  así como el historial siguiente de la versión PCRE incluida en PHP:
 </p>
 <p class="para">
  </p><table class="doctable table">
   <caption><strong>Historial de actualizaciones de la biblioteca PCRE incluida en PHP</strong></caption>
   
    <thead>
     <tr>
      <th>Versión PHP</th>
      <th>Versión PCRE actualizada</th>
      <th>Notas</th>
     </tr>

    </thead>

    <tbody class="tbody">
     <tr>
      <td>8.2.0</td>
      <td>10.40</td>
      <td class="empty"> </td>
     </tr>

     <tr>
      <td>8.1.0</td>
      <td>10.39</td>
      <td class="empty"> </td>
     </tr>

     <tr>
      <td>7.4.12, 8.0.0</td>
      <td>10.35</td>
      <td class="empty"> </td>
     </tr>

     <tr>
      <td>7.4.6</td>
      <td>10.34</td>
      <td class="empty"> </td>
     </tr>

     <tr>
      <td>7.4.0</td>
      <td>10.33</td>
      <td class="empty"> </td>
     </tr>

     <tr>
      <td>7.3.0</td>
      <td>10.32</td>
      <td class="empty"> </td>
     </tr>

     <tr>
      <td>7.2.0</td>
      <td>8.41</td>
      <td class="empty"> </td>
     </tr>

     <tr>
      <td>7.0.3</td>
      <td>8.38</td>
      <td>Ver CVE-2015-8383, CVE-2015-8386, CVE-2015-8387, CVE-2015-8389, CVE-2015-8390, CVE-2015-8391, CVE-2015-8393, CVE-2015-8394</td>
     </tr>

     <tr>
      <td>7.0.0</td>
      <td>8.37</td>
      <td>Ver CVE-2015-2325, CVE-2015-2326</td>
     </tr>

    </tbody>
   
  </table>

 
</div>
<hr>





 




<div id="pcre.configuration" class="section"><hr>
 <h2 class="title">Configuración en tiempo de ejecución</h2>
 <p class="simpara">El comportamiento de estas funciones es
afectado por la configuración en el archivo <var class="filename">php.ini</var>.</p>
 <p class="para">
  </p><table class="doctable table">
   <caption><strong>Opciones de configuración de PCRE</strong></caption>
   
    <thead>
     <tr>
      <th>Nombre</th>
      <th>Por defecto</th>
      <th>Cambiable</th>
      <th>Historial de cambios</th>
     </tr>

    </thead>

    <tbody class="tbody">
     <tr>
      <td><a href="#ini.pcre.backtrack-limit" class="link">pcre.backtrack_limit</a></td>
      <td>"1000000"</td>
      <td><strong><code><a href="#constant.ini-all">INI_ALL</a></code></strong></td>
      <td class="empty"> </td>
     </tr>

     <tr>
      <td><a href="#ini.pcre.recursion-limit" class="link">pcre.recursion_limit</a></td>
      <td>"100000"</td>
      <td><strong><code><a href="#constant.ini-all">INI_ALL</a></code></strong></td>
      <td class="empty"> </td>
     </tr>

     <tr>
      <td><a href="#ini.pcre.jit" class="link">pcre.jit</a></td>
      <td>"1"</td>
      <td><strong><code><a href="#constant.ini-all">INI_ALL</a></code></strong></td>
      <td class="empty"> </td>
     </tr>

    </tbody>
   
  </table>

  Para más detalles sobre los modos INI_*,
        refiérase a <a href="#configuration.changes.modes" class="xref">Dónde una directiva de configuración puede ser modificada</a>.
 

 <p class="para">Aquí hay una aclaración sobre
el uso de las directivas de configuración.</p>

 <p class="para">
  </p><dl>
   
    <dt id="ini.pcre.backtrack-limit">
     <code class="parameter">pcre.backtrack_limit</code>
     <span class="type"><a href="#language.types.integer" class="type integer">integer</a></span>
    </dt>
    <dd>
     <p class="para">
      Límite de retroceso de PCRE. Por defecto es 100000 para PHP &lt; 5.3.7.
     </p>
    </dd>
   
   
    <dt id="ini.pcre.recursion-limit">
     <code class="parameter">pcre.recursion_limit</code>
     <span class="type"><a href="#language.types.integer" class="type integer">integer</a></span>
    </dt>
    <dd>
     <p class="para">
      Límite de recursividad de PCRE. Por favor, observe que si establece este valor con un número
      alto se podría consumir toda la pila de procesos disponible y provocar finalmente el
      malfuncionamiento de PHP (a causa de alcanzar el límite del tamaño de la pila impuesto por el sistema
      operativo).
     </p>
    </dd>
   
   
    <dt id="ini.pcre.jit">
     <code class="parameter">pcre.jit</code>
     <span class="type"><a href="#language.types.boolean" class="type bool">bool</a></span>
    </dt>
    <dd>
     <p class="para">
      Si se va a utilizar la compilacion «just-in-time» de PCRE.
     </p>
    </dd>
   
  </dl>
 

</div>
<hr>





</div>

<hr>




 




<div id="pcre.constants" class="appendix"><hr>
 <h1 class="title">Constantes predefinidas</h1>

 <p class="simpara">Estas constantes son definidas por esta
extensión, y solo están disponibles si esta extensión ha sido compilada con
PHP, o bien cargada en tiempo de ejecución.</p>
 <table class="doctable table">
  <caption><strong>Constantes PREG</strong></caption>
  
   <thead>
    <tr>
     <th>Constantes</th>
     <th>Descripción</th>
     <th>Disponible a partir de</th>
    </tr>

   </thead>

   <tbody class="tbody">
    <tr id="constant.preg-pattern-order">
     <td>
      <strong><code><a href="#constant.preg-pattern-order">PREG_PATTERN_ORDER</a></code></strong>
      (<span class="type"><a href="#language.types.integer" class="type int">int</a></span>)
     </td>
     <td>
      Ordena los resultados de forma que <var class="varname">$matches[0]</var> contenga los
      resultados que corresponden al patrón completo, <var class="varname">$matches[1]</var> los
      que corresponden a la primera paréntesis capturante y así sucesivamente. Esta
      constante se utiliza con <span class="function"><a href="#function.preg-match-all" class="function">preg_match_all()</a></span>.
     </td>
     <td class="empty"> </td>
    </tr>

    <tr id="constant.preg-set-order">
     <td>
      <strong><code><a href="#constant.preg-set-order">PREG_SET_ORDER</a></code></strong>
      (<span class="type"><a href="#language.types.integer" class="type int">int</a></span>)
     </td>
     <td>
      Los resultados se clasifican de tal
      forma que <var class="varname">$matches[0]</var> contiene la primera
      serie de resultados, <var class="varname">$matches[1]</var> la
      segunda, etc.
      Esta constante se utiliza con <span class="function"><a href="#function.preg-match-all" class="function">preg_match_all()</a></span>.
     </td>
     <td class="empty"> </td>
    </tr>

    <tr id="constant.preg-offset-capture">
     <td>
      <strong><code><a href="#constant.preg-offset-capture">PREG_OFFSET_CAPTURE</a></code></strong>
      (<span class="type"><a href="#language.types.integer" class="type int">int</a></span>)
     </td>
     <td>
      <p class="para">
       Si esta opción está activada, para cada coincidencia encontrada,
       el desplazamiento del byte correspondiente también será devuelto.
       Tenga en cuenta que esto modifica los valores de retorno: cada elemento del array
       se convierte en un array que contiene la cadena correspondiente en el offset 0
       y su desplazamiento en la cadena analizada en el offset 1.
      </p>
     </td>
     <td class="empty"> </td>
    </tr>

    <tr id="constant.preg-split-no-empty">
     <td>
      <strong><code><a href="#constant.preg-split-no-empty">PREG_SPLIT_NO_EMPTY</a></code></strong>
      (<span class="type"><a href="#language.types.integer" class="type int">int</a></span>)
     </td>
     <td>
      Si esta opción está activada, solo las sub-cadenas no vacías
      serán devueltas por <span class="function"><a href="#function.preg-split" class="function">preg_split()</a></span>.
     </td>
     <td class="empty"> </td>
    </tr>

    <tr id="constant.preg-split-delim-capture">
     <td>
      <strong><code><a href="#constant.preg-split-delim-capture">PREG_SPLIT_DELIM_CAPTURE</a></code></strong>
      (<span class="type"><a href="#language.types.integer" class="type int">int</a></span>)
     </td>
     <td>
      <p class="para">
       Ver la descripción de <strong><code><a href="#constant.preg-offset-capture">PREG_OFFSET_CAPTURE</a></code></strong>.
       Esta bandera solo se utiliza con <span class="function"><a href="#function.preg-split" class="function">preg_split()</a></span>.
      </p>
     </td>
     <td class="empty"> </td>
    </tr>

    <tr id="constant.preg-split-offset-capture">
     <td>
      <strong><code><a href="#constant.preg-split-offset-capture">PREG_SPLIT_OFFSET_CAPTURE</a></code></strong>
      (<span class="type"><a href="#language.types.integer" class="type int">int</a></span>)
     </td>
     <td>
      Si esta constante se utiliza con <span class="function"><a href="#function.preg-split" class="function">preg_split()</a></span>,
      el desplazamiento de inicio del resultado será devuelto, además de la cadena
      resultado. Tenga en cuenta que esto cambia la naturaleza del resultado devuelto a
      un array que contiene una cadena en el offset 0 y una cadena que contiene un desplazamiento en el offset 1.
     </td>
     <td class="empty"> </td>
    </tr>

    <tr id="constant.preg-unmatched-as-null">
     <td>
      <strong><code><a href="#constant.preg-unmatched-as-null">PREG_UNMATCHED_AS_NULL</a></code></strong>
      (<span class="type"><a href="#language.types.integer" class="type int">int</a></span>)
     </td>
     <td>
      Esta constante solicita a <span class="function"><a href="#function.preg-match" class="function">preg_match()</a></span> y
      <span class="function"><a href="#function.preg-match-all" class="function">preg_match_all()</a></span>
      incluir los subpatrones sin coincidencia en <var class="varname">$matches</var> con un valor a <strong><code><a href="#constant.null">null</a></code></strong>.
      Sin esta constante, los subpatrones sin coincidencia son devueltos con una cadena vacía, como si la coincidencia estuviera vacía.
      Definir esta constante permite distinguir estos dos casos.
     </td>
     <td>7.2.0</td>
    </tr>

    <tr id="constant.preg-no-error">
     <td>
      <strong><code><a href="#constant.preg-no-error">PREG_NO_ERROR</a></code></strong>
      (<span class="type"><a href="#language.types.integer" class="type int">int</a></span>)
     </td>
     <td>
      Devuelto por la función <span class="function"><a href="#function.preg-last-error" class="function">preg_last_error()</a></span>
      si no hay error.
     </td>
     <td>5.2.0</td>
    </tr>

    <tr id="constant.preg-internal-error">
     <td>
      <strong><code><a href="#constant.preg-internal-error">PREG_INTERNAL_ERROR</a></code></strong>
      (<span class="type"><a href="#language.types.integer" class="type int">int</a></span>)
     </td>
     <td>
      Devuelto por la función <span class="function"><a href="#function.preg-last-error" class="function">preg_last_error()</a></span>
      si hay un error interno de PCRE.
     </td>
     <td>5.2.0</td>
    </tr>

    <tr id="constant.preg-backtrack-limit-error">
     <td>
      <strong><code><a href="#constant.preg-backtrack-limit-error">PREG_BACKTRACK_LIMIT_ERROR</a></code></strong>
      (<span class="type"><a href="#language.types.integer" class="type int">int</a></span>)
     </td>
     <td>
      Devuelto por la función <span class="function"><a href="#function.preg-last-error" class="function">preg_last_error()</a></span> si
      <a href="#ini.pcre.backtrack-limit" class="link">el límite de retroceso</a>
      ha sido alcanzado.
     </td>
     <td>5.2.0</td>
    </tr>

    <tr id="constant.preg-recursion-limit-error">
     <td>
      <strong><code><a href="#constant.preg-recursion-limit-error">PREG_RECURSION_LIMIT_ERROR</a></code></strong>
      (<span class="type"><a href="#language.types.integer" class="type int">int</a></span>)
     </td>
     <td>
      Devuelto por la función <span class="function"><a href="#function.preg-last-error" class="function">preg_last_error()</a></span> si
      <a href="#ini.pcre.recursion-limit" class="link">el límite de recursión</a>
      ha sido alcanzado.
     </td>
     <td>5.2.0</td>
    </tr>

    <tr id="constant.preg-bad-utf8-error">
     <td>
      <strong><code><a href="#constant.preg-bad-utf8-error">PREG_BAD_UTF8_ERROR</a></code></strong>
      (<span class="type"><a href="#language.types.integer" class="type int">int</a></span>)
     </td>
     <td>
      Devuelto por la función <span class="function"><a href="#function.preg-last-error" class="function">preg_last_error()</a></span>
      si el último error se debe a una malformación de los datos
      UTF-8 (solo durante la ejecución de una expresión en
      <a href="#reference.pcre.pattern.modifiers" class="link">modo UTF-8</a>).
     </td>
     <td>5.2.0</td>
    </tr>

    <tr id="constant.preg-bad-utf8-offset-error">
     <td>
      <strong><code><a href="#constant.preg-bad-utf8-offset-error">PREG_BAD_UTF8_OFFSET_ERROR</a></code></strong>
      (<span class="type"><a href="#language.types.integer" class="type int">int</a></span>)
     </td>
     <td>
      Devuelto por la función <span class="function"><a href="#function.preg-last-error" class="function">preg_last_error()</a></span> si el desplazamiento
      no corresponde al inicio de un punto válido UTF-8 (solo cuando se
      ejecuta una expresión en <a href="#reference.pcre.pattern.modifiers" class="link">modo
      UTF-8</a>).
     </td>
     <td>5.3.0</td>
    </tr>

    <tr id="constant.preg-jit-stacklimit-error">
     <td>
      <strong><code><a href="#constant.preg-jit-stacklimit-error">PREG_JIT_STACKLIMIT_ERROR</a></code></strong>
      (<span class="type"><a href="#language.types.integer" class="type int">int</a></span>)
     </td>
     <td>
      Devuelto por <span class="function"><a href="#function.preg-last-error" class="function">preg_last_error()</a></span> si la última función
      PCRE falló debido al límite de la pila JIT.
     </td>
     <td>7.0.0</td>
    </tr>

    <tr id="constant.pcre-version">
     <td>
      <strong><code><a href="#constant.pcre-version">PCRE_VERSION</a></code></strong>
      (<span class="type"><a href="#language.types.integer" class="type int">int</a></span>)
     </td>
     <td>
      Versión PCRE junto con la fecha de publicación
      (es decir, <code class="literal">"7.0 18-Dec-2006"</code>).
     </td>
     <td>5.2.4</td>
    </tr>

    <tr id="constant.pcre-version-major">
     <td>
      <strong><code><a href="#constant.pcre-version-major">PCRE_VERSION_MAJOR</a></code></strong>
      (<span class="type"><a href="#language.types.integer" class="type int">int</a></span>)
     </td>
     <td>
      Número de versión mayor de PCRE.
     </td>
     <td class="empty"> </td>
    </tr>

    <tr id="constant.pcre-version-minor">
     <td>
      <strong><code><a href="#constant.pcre-version-minor">PCRE_VERSION_MINOR</a></code></strong>
      (<span class="type"><a href="#language.types.integer" class="type int">int</a></span>)
     </td>
     <td>
      Número de versión menor de PCRE.
     </td>
     <td class="empty"> </td>
    </tr>

    <tr id="constant.pcre-jit-support">
     <td>
      <strong><code><a href="#constant.pcre-jit-support">PCRE_JIT_SUPPORT</a></code></strong>
      (<span class="type"><a href="#language.types.boolean" class="type bool">bool</a></span>)
     </td>
     <td>
      Indica si el soporte JIT de PCRE está disponible.
     </td>
     <td class="empty"> </td>
    </tr>

    <tr id="constant.preg-grep-invert">
     <td>
      <strong><code><a href="#constant.preg-grep-invert">PREG_GREP_INVERT</a></code></strong>
      (<span class="type"><a href="#language.types.integer" class="type int">int</a></span>)
     </td>
     <td>
      Devuelve los elementos que no coinciden con un patrón dado.
     </td>
     <td class="empty"> </td>
    </tr>

   </tbody>
  
 </table>

</div>

<hr>




 



<div id="pcre.examples" class="appendix"><hr>
 <h1 class="title">Ejemplos</h1>

 <p class="para">
  </p><div class="example" id="example-5032">
   <p><strong>Ejemplo #1 Ejemplos de patrones válidos</strong></p>
   <ul class="itemizedlist">
    <li class="listitem"><span class="simpara"><code class="literal">/&lt;\/\w+&gt;/</code></span></li>
    <li class="listitem"><span class="simpara"><code class="literal">|(\d{3})-\d+|Sm</code></span></li>
    <li class="listitem"><span class="simpara"><code class="literal">/^(?i)php[34]/</code></span></li>
    <li class="listitem"><span class="simpara"><code class="literal">{^\s+(\s+)?$}</code></span></li>
   </ul>
  </div>
 
 <p class="para">
  </p><div class="example" id="example-5033">
   <p><strong>Ejemplo #2 Ejemplos de patrones no válidos</strong></p>
   <ul class="itemizedlist">
    <li class="listitem">
     <span class="simpara">
      <code class="literal">/href='(.*)'</code> - falta el delimitador final
     </span>
    </li>
    <li class="listitem">
     <span class="simpara">
      <code class="literal">/\w+\s*\w+/J</code> - modificador 'J' desconocido
     </span>
    </li>
    <li class="listitem">
     <span class="simpara">
      <code class="literal">1-\d3-\d3-\d4|</code> - falta el delimitador inicial
     </span>
    </li>
   </ul>
  </div>
 
</div>

<hr>





 




<div id="pcre.pattern" class="part"><hr>
 <h1 class="title">Patrones PCRE</h1>
<h2>Tabla de contenidos</h2><ul class="chunklist chunklist_part"><li><a href="#reference.pcre.pattern.syntax">Sintaxis de expresiones regulares PCRE</a></li><li><a href="#reference.pcre.pattern.modifiers">Opciones disponibles para las expresiones regulares</a></li><li><a href="#reference.pcre.pattern.differences">Diferencias con Perl</a></li></ul>


 



<div id="reference.pcre.pattern.syntax" class="chapter"><hr>
 <h1 class="title">Sintaxis de patrones</h1>
<h2>Tabla de contenidos</h2><ul class="chunklist chunklist_chapter"><li><a href="#regexp.introduction">Introducción</a></li><li><a href="#regexp.reference.delimiters">Delimitadores</a></li><li><a href="#regexp.reference.meta">Metacaracteres</a></li><li><a href="#regexp.reference.escape">Secuencias de escape</a></li><li><a href="#regexp.reference.unicode">Propiedades de caracteres Unicode</a></li><li><a href="#regexp.reference.anchors">Anclajes</a></li><li><a href="#regexp.reference.dot">Punto</a></li><li><a href="#regexp.reference.character-classes">Clases de caracteres</a></li><li><a href="#regexp.reference.alternation">Alternancia</a></li><li><a href="#regexp.reference.internal-options">Configuración de opciones internas</a></li><li><a href="#regexp.reference.subpatterns">Subpatrones</a></li><li><a href="#regexp.reference.repetition">Repetición</a></li><li><a href="#regexp.reference.back-references">Referencias inversas</a></li><li><a href="#regexp.reference.assertions">Afirmaciones</a></li><li><a href="#regexp.reference.onlyonce">Subpatrones de una sola vez</a></li><li><a href="#regexp.reference.conditional">Subpatrones condicionales</a></li><li><a href="#regexp.reference.comments">Comentarios</a></li><li><a href="#regexp.reference.recursive">Patrones recursivos</a></li><li><a href="#regexp.reference.performance">Rendimiento</a></li></ul>

 

 <div id="regexp.introduction" class="section"><hr>
  <h2 class="title">Introducción</h2>
  <p class="para">
   La sintaxis y semántica de las expresiones regulares
   soportadas por PCRE se describen en esta sección. Las expresiones regulares también se
   describen en la documentación de Perl y en varios
   otros libros, algunos de los cuales tienen ejemplos abundantes. El libro
   "Mastering Regular Expressions" de Jeffrey
   Friedl, publicado por O'Reilly (ISBN 1-56592-257-3), las cubre en gran detalle.
   La descripción aquí está destinada como documentación de referencia.
  </p>
  <p class="para">
   Una expresión regular es un patrón que se compara con una
   cadena de sujeto de izquierda a derecha. La mayoría de los caracteres representan
   a sí mismos en un patrón, y coinciden con los
   caracteres correspondientes en el sujeto. Como ejemplo trivial, el patrón
   <code class="literal">The quick brown fox</code>
   coincide con una parte de una cadena de sujeto que es idéntica
   a sí misma.
  </p>
 </div>
<hr>

 <div id="regexp.reference.delimiters" class="section"><hr>
  <h2 class="title">Delimitadores</h2>
  <p class="para">
   Al usar las funciones PCRE, es obligatorio que el patrón esté encerrado
   por <em>delimitadores</em>. Un delimitador puede ser cualquier carácter no alfanumérico,
   no barra invertida, no espacio en blanco.
   Los espacios en blanco iniciales antes de un delimitador válido se ignoran silenciosamente.
  </p>
  <p class="para">
   Los delimitadores comúnmente utilizados son las barras inclinadas hacia adelante (<code class="literal">/</code>), signos de número
   (<code class="literal">#</code>) y tildes (<code class="literal">~</code>). Los siguientes son ejemplos de patrones delimitados válidos.
   </p><div class="informalexample">
    <div class="example-contents">
<div class="annotation-interactive cdata"><pre>
/foo bar/
#^[^0-9]$#
+php+
%[a-zA-Z0-9_-]%
</pre></div>
    </div>

   </div>
  
  <p class="para">
   También es posible usar
   delimitadores de estilo de corchetes donde los corchetes de apertura y cierre son el delimitador de inicio y fin, respectivamente. <code class="literal">()</code>,
   <code class="literal">{}</code>, <code class="literal">[]</code> y <code class="literal">&lt;&gt;</code>
   son todos pares de delimitadores de estilo de corchetes válidos.
   </p><div class="informalexample">
    <div class="example-contents">
<div class="annotation-interactive cdata"><pre>
(this [is] a (pattern))
{this [is] a (pattern)}
[this [is] a (pattern)]
&lt;this [is] a (pattern)&gt;
</pre></div>
    </div>

   </div>
   Los delimitadores de estilo de corchetes no necesitan ser escapados cuando se usan como metacaracteres dentro del patrón, pero como con otros delimitadores deben ser escapados cuando se usan como caracteres literales.
  
  <p class="para">
   Si el delimitador necesita coincidir dentro del patrón debe ser
   escapado usando una barra invertida. Si el delimitador aparece con frecuencia dentro del
   patrón, es una buena idea elegir otro delimitador para aumentar
   la legibilidad.
   </p><div class="informalexample">
    <div class="example-contents">
<div class="annotation-interactive cdata"><pre>
/http:\/\//
#http://#
</pre></div>
    </div>

   </div>
   La función <span class="function"><a href="#function.preg-quote" class="function">preg_quote()</a></span> puede ser utilizada para escapar una cadena
   para inyectarla en un patrón y su segundo parámetro opcional puede ser utilizado
   para especificar el delimitador a escapar.
  
  <p class="para">
   Puede agregar <a href="#reference.pcre.pattern.modifiers" class="link">modificadores de patrón</a> después del delimitador final. El siguiente es un ejemplo
   de coincidencia sin distinción de mayúsculas y minúsculas:
   </p><div class="informalexample">
    <div class="example-contents">
<div class="annotation-interactive cdata"><pre>
#[a-z]#i
</pre></div>
    </div>

   </div>
  
 </div>
<hr>

 <div id="regexp.reference.meta" class="section"><hr>
  <h2 class="title">Metacaracteres</h2>
  <p class="para">
   El poder de las expresiones regulares proviene de la
   capacidad de incluir alternativas y repeticiones en el
   patrón. Estas se codifican en el patrón mediante el uso de
   <em>metacaracteres</em>, que no se representan a sí mismos, sino que se interpretan de alguna manera especial.
  </p>
  <p class="para">
   Hay dos conjuntos diferentes de metacaracteres: aquellos que
   se reconocen en cualquier parte del patrón excepto dentro de corchetes, y aquellos que se reconocen dentro de corchetes.
   Fuera de corchetes, los metacaracteres son los siguientes:

   </p><table class="doctable table">
     <caption><strong>Metacaracteres fuera de corchetes</strong></caption>
    
     <thead>
      <tr>
       <th>Metacaracter</th><th>Descripción</th>
      </tr>

     </thead>

     <tbody class="tbody">
      <tr>
       <td>\</td><td>carácter de escape general con varios usos</td>
      </tr>

      <tr>
       <td>^</td><td>asegurar el inicio del sujeto (o línea, en modo multiline)</td>
      </tr>

      <tr>
       <td>$</td><td>asegurar el final del sujeto o antes de un salto de línea de terminación (o final de línea, en modo multiline)</td>
      </tr>

      <tr>
       <td>.</td><td>coincidir con cualquier carácter excepto salto de línea (por defecto)</td>
      </tr>

      <tr>
       <td>[</td><td>inicio de definición de clase de caracteres</td>
      </tr>

      <tr>
       <td>]</td><td>fin de definición de clase de caracteres</td>
      </tr>

      <tr>
       <td>|</td><td>inicio de rama alternativa</td>
      </tr>

      <tr>
       <td>(</td><td>inicio de subpatrón</td>
      </tr>

      <tr>
       <td>)</td><td>fin de subpatrón</td>
      </tr>

      <tr>
       <td>?</td><td>extiende el significado de (, también 0 o 1 cuantificador, también hace que los cuantificadores codiciosos sean perezosos (ver <a href="#regexp.reference.repetition" class="link">repetición</a>)</td>
      </tr>

      <tr>
       <td>*</td><td>cuantificador 0 o más</td>
      </tr>

      <tr>
       <td>+</td><td>cuantificador 1 o más</td>
      </tr>

      <tr>
       <td>{</td><td>inicio de cuantificador min/max</td>
      </tr>

      <tr>
       <td>}</td><td>fin de cuantificador min/max</td>
      </tr>

     </tbody>
    
   </table>


   Una parte de un patrón que está dentro de corchetes se llama
   <a href="#regexp.reference.character-classes" class="link">clase de caracteres</a>. En una clase de caracteres los únicos
   metacaracteres son:

   <table class="doctable table">
     <caption><strong>Metacaracteres dentro de corchetes (<em>clases de caracteres</em>)</strong></caption>
    
     <thead>
      <tr>
       <th>Metacaracter</th><th>Descripción</th>
      </tr>

     </thead>

     <tbody class="tbody">
      <tr>
       <td>\</td><td>carácter de escape general</td>
      </tr>

      <tr>
       <td>^</td><td>niega la clase, pero solo si es el primer carácter</td>
      </tr>

      <tr>
       <td>-</td><td>indica rango de caracteres</td>
      </tr>

     </tbody>
    
   </table>


   Las siguientes secciones describen el uso de cada uno de los
   metacaracteres.
  
 </div>
<hr>


 <div id="regexp.reference.escape" class="section"><hr>
  <h2 class="title">Secuencias de escape</h2>
  <p class="para">
   El carácter de barra invertida tiene varios usos. En primer lugar, si está
   seguido por un carácter no alfanumérico, elimina cualquier
   significado especial que el carácter pueda tener. Este uso de
   barra invertida como carácter de escape se aplica tanto dentro como fuera de clases de caracteres.
  </p>
  <p class="para">
   Por ejemplo, si desea coincidir con un carácter "*", escribe
   "\*" en el patrón. Esto se aplica ya sea que el
   carácter siguiente sería interpretado de otra manera como un
   metacarácter, por lo que siempre es seguro preceder un no alfanumérico
   con "\" para especificar que representa a sí mismo. En
   particular, si desea coincidir con una barra invertida, escribe "\\".
  </p>
  <blockquote class="note"><p><strong class="note">Nota</strong>: 
   </p><p class="para">
    Las cadenas de PHP con comillas simples y dobles <a href="#language.types.string.syntax" class="link">tienen</a> un significado especial de barra invertida. Por lo tanto, si \ debe coincidir con una expresión regular \\, entonces "\\\\" o '\\\\' debe usarse en el código PHP.
   </p>
  </blockquote>
  <p class="para">
   Si un patrón se compila con la
   <a href="#reference.pcre.pattern.modifiers" class="link">opción PCRE_EXTENDED</a>,
   el espacio en blanco en el patrón (excepto en una clase de caracteres) y
   los caracteres entre un "#" fuera de una clase de caracteres y el siguiente carácter de nueva línea
   se ignoran. Una barra invertida de escape puede usarse para incluir un
   carácter de espacio en blanco o "#" como parte del patrón.
  </p>
  <p class="para">
   Un segundo uso de la barra invertida proporciona una manera de codificar
   caracteres no imprimibles en patrones de manera visible. No hay restricción sobre la aparición de caracteres no imprimibles,
   aparte del cero binario que termina un patrón,
   pero cuando un patrón se está preparando mediante edición de texto, generalmente es
   más fácil usar una de las siguientes secuencias de escape
   que el carácter binario que representan:
  </p>
  <p class="para">
   </p><dl>
    
     <dt><em>\a</em></dt>
     <dd>
      <span class="simpara">alarma, es decir, el carácter BEL (hex 07)</span>
     </dd>
    
    
     <dt><em>\cx</em></dt>
     <dd>
      <span class="simpara">"control-x", donde x es cualquier carácter</span>
     </dd>
    
    
     <dt><em>\e</em></dt>
     <dd>
      <span class="simpara">escape (hex 1B)</span>
     </dd>
    
    
     <dt><em>\f</em></dt>
     <dd>
      <span class="simpara">salto de página (hex 0C)</span>
     </dd>
    
    
     <dt><em>\n</em></dt>
     <dd>
      <span class="simpara">nueva línea (hex 0A)</span>
     </dd>
    
    
     <dt><em>\p{xx}</em></dt>
     <dd>
      <span class="simpara">
       un carácter con la propiedad xx, ver
       <a href="#regexp.reference.unicode" class="link">propiedades unicode</a>
       para más información
      </span>
     </dd>
    
    
     <dt><em>\P{xx}</em></dt>
     <dd>
      <span class="simpara">
       un carácter sin la propiedad xx, ver
       <a href="#regexp.reference.unicode" class="link">propiedades unicode</a>
       para más información
      </span>
     </dd>
    
    
     <dt><em>\r</em></dt>
     <dd>
      <span class="simpara">retorno de carro (hex 0D)</span>
     </dd>
    
    
     <dt><em>\R</em></dt>
     <dd>
      <span class="simpara">salto de línea: coincide con \n, \r y \r\n</span>
     </dd>
    
    
     <dt><em>\t</em></dt>
     <dd>
      <span class="simpara">tabulador (hex 09)</span>
     </dd>
    
    
     <dt><em>\xhh</em></dt>
     <dd>
      <span class="simpara">
       carácter con código hex hh
      </span>
     </dd>
    
    
     <dt><em>\ddd</em></dt>
     <dd>
      <span class="simpara">carácter con código octal ddd, o referencia inversa</span>
     </dd>
    
   </dl>
  
  <p class="para">
   El efecto preciso de "<code class="literal">\cx</code>" es el siguiente:
   si "<code class="literal">x</code>" es una letra minúscula, se convierte
   a mayúscula. Luego se invierte el bit 6 del carácter (hex 40).
   Así, "<code class="literal">\cz</code>" se convierte en hex 1A, pero
   "<code class="literal">\c{</code>" se convierte en hex 3B, mientras que "<code class="literal">\c;</code>"
   se convierte en hex 7B.
  </p>
  <p class="para">
   Después de "<code class="literal">\x</code>", se leen hasta dos dígitos hexadecimales (las letras pueden estar en mayúsculas o minúsculas).
   En <em>modo UTF-8</em>, "<code class="literal">\x{...}</code>" está permitido, donde el contenido de las llaves es una cadena de dígitos hexadecimales. Se interpreta como un carácter UTF-8 cuyo número de código es el número hexadecimal dado. La secuencia de escape hexadecimal original,
   <code class="literal">\xhh</code>, coincide con un carácter UTF-8 de dos bytes si el valor es mayor que 127.
  </p>
  <p class="para">
   Después de "<code class="literal">\0</code>" se leen hasta dos dígitos octales adicionales.
   En ambos casos, si hay menos de dos dígitos, solo se usan los que
   están presentes. Así, la secuencia "<code class="literal">\0\x\07</code>"
   especifica dos ceros binarios seguidos de un carácter BEL. Asegúrese de
   proporcionar dos dígitos después del cero inicial si el carácter
   que sigue es él mismo un dígito octal.
  </p>
  <p class="para">
   El manejo de una barra invertida seguida de un dígito que no sea 0
   es complicado. Fuera de una clase de caracteres, PCRE lo lee
   y cualquier dígito siguiente como un número decimal. Si el número
   es menor que 10, o si ha habido al menos esa cantidad de
   paréntesis de apertura de captura anteriores en la expresión, la
   secuencia completa se toma como una <em>referencia inversa</em>. Una descripción
   de cómo funciona esto se da más adelante, después de la discusión
   de subpatrones entre paréntesis.
  </p>
  <p class="para">
   Dentro de una clase de caracteres, o si el número decimal es
   mayor que 9 y no ha habido tantas subpatrones de captura, PCRE vuelve a leer
   hasta tres dígitos octales siguientes
   a la barra invertida, y genera un solo byte a partir de
   los 8 bits menos significativos del valor. Los dígitos posteriores se representan a sí mismos. Por ejemplo:
  </p>
  <p class="para">
   </p><dl>
    
     <dt><em>\040</em></dt>
     <dd><span class="simpara">es otra forma de escribir un espacio</span></dd>
    
    
     <dt><em>\40</em></dt>
     <dd>
      <span class="simpara">
       es lo mismo, siempre que haya menos de 40
       subpatrones de captura anteriores
      </span>
     </dd>
    
    
     <dt><em>\7</em></dt>
     <dd><span class="simpara">siempre es una referencia inversa</span></dd>
    
    
     <dt><em>\11</em></dt>
     <dd>
      <span class="simpara">
       podría ser una referencia inversa, o otra forma de
       escribir un tabulador
      </span>
     </dd>
    
    
     <dt><em>\011</em></dt>
     <dd><span class="simpara">siempre es un tabulador</span></dd>
    
    
     <dt><em>\0113</em></dt>
     <dd><span class="simpara">es un tabulador seguido del carácter "3"</span></dd>
    
    
     <dt><em>\113</em></dt>
     <dd>
      <span class="simpara">
       es el carácter con código octal 113 (ya que no puede haber más de 99 referencias inversas)
      </span>
     </dd>
    
    
     <dt><em>\377</em></dt>
     <dd><span class="simpara">es un byte compuesto completamente de 1 bits</span></dd>
    
    
     <dt><em>\81</em></dt>
     <dd>
      <span class="simpara">
       es una referencia inversa, o un cero binario
       seguido de los dos caracteres "8" y "1"
      </span>
     </dd>
    
   </dl>
  
  <p class="para">
   Tenga en cuenta que los valores octales de 100 o más no deben introducirse con un cero inicial, ya que nunca se leen más de tres dígitos octales.
  </p>
  <p class="para">
   Todas las secuencias que definen un valor de un solo byte pueden usarse tanto dentro como fuera de clases de caracteres. Además,
   dentro de una clase de caracteres, la secuencia "<code class="literal">\b</code>"
   se interpreta como el carácter de retroceso (hex 08). Fuera de una clase de caracteres tiene un significado diferente (ver más abajo).
  </p>
  <p class="para">
   El tercer uso de la barra invertida es para especificar tipos de caracteres genéricos:
  </p>
  <p class="para">
   </p><dl>
    
     <dt><em>\d</em></dt>
     <dd><span class="simpara">cualquier dígito decimal</span></dd>
    
    
     <dt><em>\D</em></dt>
     <dd><span class="simpara">cualquier carácter que no sea un dígito decimal</span></dd>
    
    
     <dt><em>\h</em></dt>
     <dd><span class="simpara">cualquier carácter de espacio en blanco horizontal</span></dd>
    
    
     <dt><em>\H</em></dt>
     <dd><span class="simpara">cualquier carácter que no sea un carácter de espacio en blanco horizontal</span></dd>
    
    
     <dt><em>\s</em></dt>
     <dd><span class="simpara">cualquier carácter de espacio en blanco</span></dd>
    
    
     <dt><em>\S</em></dt>
     <dd><span class="simpara">cualquier carácter que no sea un carácter de espacio en blanco</span></dd>
    
    
     <dt><em>\v</em></dt>
     <dd><span class="simpara">cualquier carácter de espacio en blanco vertical</span></dd>
    
    
     <dt><em>\V</em></dt>
     <dd><span class="simpara">cualquier carácter que no sea un carácter de espacio en blanco vertical</span></dd>
    
    
     <dt><em>\w</em></dt>
     <dd><span class="simpara">cualquier carácter de "palabra"</span></dd>
    
    
     <dt><em>\W</em></dt>
     <dd><span class="simpara">cualquier carácter "no palabra"</span></dd>
    
   </dl>
  
  <p class="para">
   Cada par de secuencias de escape divide el conjunto completo de
   caracteres en dos conjuntos disjuntos. Cualquier carácter
   dado coincide con uno, y solo uno, de cada par.
  </p>
  <p class="para">
   Los caracteres de "espacio en blanco" son HT (9), LF (10), FF (12), CR (13),
   y espacio (32). Sin embargo, si se está realizando una coincidencia específica de la configuración regional,
   los caracteres con puntos de código en el rango 128-255 también pueden considerarse
   como caracteres de espacio en blanco, por ejemplo, NBSP (A0).
  </p>
  <p class="para">
   Un carácter de "palabra" es cualquier letra o dígito o el carácter de subrayado,
   es decir, cualquier carácter que pueda ser parte de
   una "palabra" de Perl. La definición de letras y dígitos está
   controlada por las tablas de caracteres de PCRE, y puede variar si se está realizando una coincidencia específica de la configuración regional. Por ejemplo, en la configuración regional "fr" (francés), algunos códigos de caracteres mayores que 128 se usan para letras acentuadas,
   y estas coinciden con <code class="literal">\w</code>.
  </p>
  <p class="para">
   Estas secuencias de tipos de caracteres pueden aparecer tanto dentro como
   fuera de clases de caracteres. Cada una coincide con un carácter de
   tipo apropiado. Si el punto de coincidencia actual está al final
   de la cadena de sujeto, todas fallan, ya que no hay carácter para coincidir.
  </p>
  <p class="para">
   El cuarto uso de la barra invertida es para ciertas afirmaciones simples.
   Una afirmación especifica una condición que debe cumplirse
   en un punto particular en una coincidencia, sin consumir ningún
   carácter de la cadena de sujeto. El uso de subpatrones
   para afirmaciones más complicadas se describe a continuación. Las
   afirmaciones con barra invertida son
  </p>
  <p class="para">
   </p><dl>
    
     <dt><em>\b</em></dt>
     <dd><span class="simpara">límite de palabra</span></dd>
    
    
     <dt><em>\B</em></dt>
     <dd><span class="simpara">no es un límite de palabra</span></dd>
    
    
     <dt><em>\A</em></dt>
     <dd><span class="simpara">inicio del sujeto (independiente del modo multiline)</span></dd>
    
    
     <dt><em>\Z</em></dt>
     <dd>
      <span class="simpara">
       final del sujeto o salto de línea al final (independiente del
       modo multiline)
      </span>
     </dd>
    
    
     <dt><em>\z</em></dt>
     <dd><span class="simpara">final del sujeto (independiente del modo multiline)</span></dd>
    
    
     <dt><em>\G</em></dt>
     <dd><span class="simpara">primera posición de coincidencia en el sujeto</span></dd>
    
   </dl>
  
  <p class="para">
   Estas afirmaciones no pueden aparecer en clases de caracteres (pero
   note que "<code class="literal">\b</code>" tiene un significado diferente, a saber, el carácter de retroceso, dentro de una clase de caracteres).
  </p>
  <p class="para">
   Un límite de palabra es una posición en la cadena de sujeto donde
   el carácter actual y el carácter anterior no coinciden ambos
   con <code class="literal">\w</code> o <code class="literal">\W</code> (es decir, uno coincide
   con <code class="literal">\w</code> y el otro coincide
   con <code class="literal">\W</code>), o el inicio o final de la cadena si el primer
   o último carácter coincide con <code class="literal">\w</code>, respectivamente.
  </p>
  <p class="para">
   Las afirmaciones <code class="literal">\A</code>, <code class="literal">\Z</code> y
   <code class="literal">\z</code> difieren de las afirmaciones tradicionales
   de circunflejo y dólar (descritas en <a href="#regexp.reference.anchors" class="link">anclajes</a> )
   en que solo coinciden en el inicio y final exactos de la cadena de sujeto,
   independientemente de las opciones establecidas. No se ven afectadas por las
   opciones <a href="#reference.pcre.pattern.modifiers" class="link">PCRE_MULTILINE</a> o
   <a href="#reference.pcre.pattern.modifiers" class="link">PCRE_DOLLAR_ENDONLY</a>.
   La diferencia entre <code class="literal">\Z</code> y
   <code class="literal">\z</code> es que <code class="literal">\Z</code> coincide antes de un salto de línea que es el último carácter de la cadena así como al final de
   la cadena, mientras que <code class="literal">\z</code> solo coincide al final.
  </p>
  <p class="para">
   La afirmación <code class="literal">\G</code> es verdadera solo cuando la posición de coincidencia actual está en el punto de inicio de la coincidencia, como se especifica por
   el argumento <code class="parameter">offset</code> de
   <span class="function"><a href="#function.preg-match" class="function">preg_match()</a></span>. Difiere de <code class="literal">\A</code>
   cuando el valor de <code class="parameter">offset</code> no es cero.
  </p>

  <p class="para">
   <code class="literal">\Q</code> y <code class="literal">\E</code> pueden usarse para ignorar
   metacaracteres de regexp en el patrón. Por ejemplo:
   <code class="literal">\w+\Q.$.\E$</code> coincidirá con uno o más caracteres de palabra,
   seguido de literales <code class="literal">.$.</code> y anclado al final
   de la cadena. Tenga en cuenta que esto no cambia el comportamiento de
   los delimitadores; por ejemplo, el patrón <code class="literal">#\Q#\E#$</code>
   no es válido, porque el segundo <code class="literal">#</code> marca el final del patrón, y el <code class="literal">\E#</code> se interpreta como modificadores inválidos.
  </p>

  <p class="para">
   <code class="literal">\K</code> puede usarse para restablecer el inicio de la coincidencia.
   Por ejemplo, el patrón <code class="literal">foo\Kbar</code> coincide
   con "foobar", pero informa que ha coincidido con "bar". El uso de
   <code class="literal">\K</code> no interfiere con la configuración de subcadenas capturadas. Por ejemplo, cuando el patrón <code class="literal">(foo)\Kbar</code>
   coincide con "foobar", la primera subcadena sigue configurada en "foo".
  </p>

 </div>
<hr>


 <div id="regexp.reference.unicode" class="section"><hr>
  <h2 class="title">Propiedades de caracteres Unicode</h2>
  <p class="para">
   Desde 5.1.0, tres
   secuencias de escape adicionales para coincidir con tipos de caracteres genéricos están disponibles
   cuando se selecciona el <em>modo UTF-8</em>. Son:
  </p>
  <dl>
   
    <dt><em>\p{xx}</em></dt>
    <dd><span class="simpara">un carácter con la propiedad xx</span></dd>
   
   
    <dt><em>\P{xx}</em></dt>
    <dd><span class="simpara">un carácter sin la propiedad xx</span></dd>
   
   
    <dt><em>\X</em></dt>
    <dd><span class="simpara">una secuencia Unicode extendida</span></dd>
   
  </dl>
  <p class="para">
   Los nombres de propiedades representados por <code class="literal">xx</code> arriba están limitados
   a las propiedades generales de categoría Unicode. Cada carácter tiene exactamente una
   de estas propiedades, especificada por una abreviatura de dos letras. Para compatibilidad con
   Perl, la negación puede especificarse incluyendo una circunflejo entre la llave de apertura y el nombre de la propiedad. Por ejemplo, <code class="literal">\p{^Lu}</code>
   es lo mismo que <code class="literal">\P{Lu}</code>.
  </p>
  <p class="para">
   Si solo se especifica una letra con <code class="literal">\p</code> o
   <code class="literal">\P</code>, incluye todas las propiedades que comienzan con esa
   letra. En este caso, en ausencia de negación, las llaves en la
   secuencia de escape son opcionales; estos dos ejemplos tienen el mismo efecto:
  </p>
  <div class="informalexample">
   <div class="example-contents">
<div class="annotation-interactive cdata"><pre>
\p{L}
\pL
</pre></div>
   </div>

  </div>
  <table class="doctable table">
   <caption><strong>Códigos de propiedades admitidos</strong></caption>
   
    <thead>
     <tr>
      <th>Propiedad</th>
      <th>Coincide con</th>
      <th>Notas</th>
     </tr>

    </thead>

    <tbody class="tbody">
     <tr>
      <td><code class="literal">C</code></td>
      <td>Otro</td>
      <td class="empty"> </td>
     </tr>

     <tr>
      <td><code class="literal">Cc</code></td>
      <td>Control</td>
      <td class="empty"> </td>
     </tr>

     <tr>
      <td><code class="literal">Cf</code></td>
      <td>Formato</td>
      <td class="empty"> </td>
     </tr>

     <tr>
      <td><code class="literal">Cn</code></td>
      <td>No asignado</td>
      <td class="empty"> </td>
     </tr>

     <tr>
      <td><code class="literal">Co</code></td>
      <td>Uso privado</td>
      <td class="empty"> </td>
     </tr>

     <tr>
      <td><code class="literal">Cs</code></td>
      <td>Sustituto</td>
      <td class="empty"> </td>
     </tr>

     <tr>
      <td><code class="literal">L</code></td>
      <td>Letra</td>
      <td>
       Incluye las siguientes propiedades: <code class="literal">Ll</code>,
       <code class="literal">Lm</code>, <code class="literal">Lo</code>, <code class="literal">Lt</code> y
       <code class="literal">Lu</code>.
      </td>
     </tr>

     <tr>
      <td><code class="literal">Ll</code></td>
      <td>Letra minúscula</td>
      <td class="empty"> </td>
     </tr>

     <tr>
      <td><code class="literal">Lm</code></td>
      <td>Letra modificadora</td>
      <td class="empty"> </td>
     </tr>

     <tr>
      <td><code class="literal">Lo</code></td>
      <td>Otra letra</td>
      <td class="empty"> </td>
     </tr>

     <tr>
      <td><code class="literal">Lt</code></td>
      <td>Letra con mayúscula inicial</td>
      <td class="empty"> </td>
     </tr>

     <tr>
      <td><code class="literal">Lu</code></td>
      <td>Letra mayúscula</td>
      <td class="empty"> </td>
     </tr>

     <tr>
      <td><code class="literal">M</code></td>
      <td>Marca</td>
      <td class="empty"> </td>
     </tr>

     <tr>
      <td><code class="literal">Mc</code></td>
      <td>Marca de espacio</td>
      <td class="empty"> </td>
     </tr>

     <tr>
      <td><code class="literal">Me</code></td>
      <td>Marca de cierre</td>
      <td class="empty"> </td>
     </tr>

     <tr>
      <td><code class="literal">Mn</code></td>
      <td>Marca no espaciada</td>
      <td class="empty"> </td>
     </tr>

     <tr>
      <td><code class="literal">N</code></td>
      <td>Número</td>
      <td class="empty"> </td>
     </tr>

     <tr>
      <td><code class="literal">Nd</code></td>
      <td>Número decimal</td>
      <td class="empty"> </td>
     </tr>

     <tr>
      <td><code class="literal">Nl</code></td>
      <td>Número de letra</td>
      <td class="empty"> </td>
     </tr>

     <tr>
      <td><code class="literal">No</code></td>
      <td>Otro número</td>
      <td class="empty"> </td>
     </tr>

     <tr>
      <td><code class="literal">P</code></td>
      <td>Puntuación</td>
      <td class="empty"> </td>
     </tr>

     <tr>
      <td><code class="literal">Pc</code></td>
      <td>Puntuación de conexión</td>
      <td class="empty"> </td>
     </tr>

     <tr>
      <td><code class="literal">Pd</code></td>
      <td>Puntuación de guión</td>
      <td class="empty"> </td>
     </tr>

     <tr>
      <td><code class="literal">Pe</code></td>
      <td>Puntuación de cierre</td>
      <td class="empty"> </td>
     </tr>

     <tr>
      <td><code class="literal">Pf</code></td>
      <td>Puntuación final</td>
      <td class="empty"> </td>
     </tr>

     <tr>
      <td><code class="literal">Pi</code></td>
      <td>Puntuación inicial</td>
      <td class="empty"> </td>
     </tr>

     <tr>
      <td><code class="literal">Po</code></td>
      <td>Otra puntuación</td>
      <td class="empty"> </td>
     </tr>

     <tr>
      <td><code class="literal">Ps</code></td>
      <td>Puntuación de apertura</td>
      <td class="empty"> </td>
     </tr>

     <tr>
      <td><code class="literal">S</code></td>
      <td>Símbolo</td>
      <td class="empty"> </td>
     </tr>

     <tr>
      <td><code class="literal">Sc</code></td>
      <td>Símbolo de moneda</td>
      <td class="empty"> </td>
     </tr>

     <tr>
      <td><code class="literal">Sk</code></td>
      <td>Símbolo modificador</td>
      <td class="empty"> </td>
     </tr>

     <tr>
      <td><code class="literal">Sm</code></td>
      <td>Símbolo matemático</td>
      <td class="empty"> </td>
     </tr>

     <tr>
      <td><code class="literal">So</code></td>
      <td>Otro símbolo</td>
      <td>Incluye emojis</td>
     </tr>

     <tr>
      <td><code class="literal">Z</code></td>
      <td>Separador</td>
      <td class="empty"> </td>
     </tr>

     <tr>
      <td><code class="literal">Zl</code></td>
      <td>Separador de línea</td>
      <td class="empty"> </td>
     </tr>

     <tr>
      <td><code class="literal">Zp</code></td>
      <td>Separador de párrafo</td>
      <td class="empty"> </td>
     </tr>

     <tr>
      <td><code class="literal">Zs</code></td>
      <td>Separador de espacio</td>
      <td class="empty"> </td>
     </tr>

    </tbody>
   
  </table>

  <p class="para">
   Las propiedades extendidas como <code class="literal">InMusicalSymbols</code> no
   son soportadas por PCRE.
  </p>
  <p class="para">
   Especificar coincidencia sin distinción de mayúsculas y minúsculas no afecta estas secuencias de escape.
   Por ejemplo, <code class="literal">\p{Lu}</code> siempre coincide solo con letras mayúsculas.
  </p>
  <p class="para">
   Los conjuntos de caracteres Unicode están definidos como pertenecientes a ciertos guiones. Un
   carácter de uno de estos conjuntos puede coincidir usando un nombre de guión. Por
   ejemplo:
  </p>
  <ul class="itemizedlist">
   <li class="listitem">
    <span class="simpara"><code class="literal">\p{Greek}</code></span>
   </li>
   <li class="listitem">
    <span class="simpara"><code class="literal">\P{Han}</code></span>
   </li>
  </ul>
  <p class="para">
   Aquellos que no son parte de un guión identificado se agrupan juntos como
   <code class="literal">Common</code>. La lista actual de guiones es:
  </p>
  <table class="doctable table">
   <caption><strong>Guiones admitidos</strong></caption>
   
    <tbody class="tbody">
     <tr>
      <td><code class="literal">Arabic</code></td>
      <td><code class="literal">Armenian</code></td>
      <td><code class="literal">Avestan</code></td>
      <td><code class="literal">Balinese</code></td>
      <td><code class="literal">Bamum</code></td>
     </tr>

     <tr>
      <td><code class="literal">Batak</code></td>
      <td><code class="literal">Bengali</code></td>
      <td><code class="literal">Bopomofo</code></td>
      <td><code class="literal">Brahmi</code></td>
      <td><code class="literal">Braille</code></td>
     </tr>

     <tr>
      <td><code class="literal">Buginese</code></td>
      <td><code class="literal">Buhid</code></td>
      <td><code class="literal">Canadian_Aboriginal</code></td>
      <td><code class="literal">Carian</code></td>
      <td><code class="literal">Chakma</code></td>
     </tr>

     <tr>
      <td><code class="literal">Cham</code></td>
      <td><code class="literal">Cherokee</code></td>
      <td><code class="literal">Common</code></td>
      <td><code class="literal">Coptic</code></td>
      <td><code class="literal">Cuneiform</code></td>
     </tr>

     <tr>
      <td><code class="literal">Cypriot</code></td>
      <td><code class="literal">Cyrillic</code></td>
      <td><code class="literal">Deseret</code></td>
      <td><code class="literal">Devanagari</code></td>
      <td><code class="literal">Egyptian_Hieroglyphs</code></td>
     </tr>

     <tr>
      <td><code class="literal">Ethiopic</code></td>
      <td><code class="literal">Georgian</code></td>
      <td><code class="literal">Glagolitic</code></td>
      <td><code class="literal">Gothic</code></td>
      <td><code class="literal">Greek</code></td>
     </tr>

     <tr>
      <td><code class="literal">Gujarati</code></td>
      <td><code class="literal">Gurmukhi</code></td>
      <td><code class="literal">Han</code></td>
      <td><code class="literal">Hangul</code></td>
      <td><code class="literal">Hanunoo</code></td>
     </tr>

     <tr>
      <td><code class="literal">Hebrew</code></td>
      <td><code class="literal">Hiragana</code></td>
      <td><code class="literal">Imperial_Aramaic</code></td>
      <td><code class="literal">Inherited</code></td>
      <td><code class="literal">Inscriptional_Pahlavi</code></td>
     </tr>

     <tr>
      <td><code class="literal">Inscriptional_Parthian</code></td>
      <td><code class="literal">Javanese</code></td>
      <td><code class="literal">Kaithi</code></td>
      <td><code class="literal">Kannada</code></td>
      <td><code class="literal">Katakana</code></td>
     </tr>

     <tr>
      <td><code class="literal">Kayah_Li</code></td>
      <td><code class="literal">Kharoshthi</code></td>
      <td><code class="literal">Khmer</code></td>
      <td><code class="literal">Lao</code></td>
      <td><code class="literal">Latin</code></td>
     </tr>

     <tr>
      <td><code class="literal">Lepcha</code></td>
      <td><code class="literal">Limbu</code></td>
      <td><code class="literal">Linear_B</code></td>
      <td><code class="literal">Lisu</code></td>
      <td><code class="literal">Lycian</code></td>
     </tr>

     <tr>
      <td><code class="literal">Lydian</code></td>
      <td><code class="literal">Malayalam</code></td>
      <td><code class="literal">Mandaic</code></td>
      <td><code class="literal">Meetei_Mayek</code></td>
      <td><code class="literal">Meroitic_Cursive</code></td>
     </tr>

     <tr>
      <td><code class="literal">Meroitic_Hieroglyphs</code></td>
      <td><code class="literal">Miao</code></td>
      <td><code class="literal">Mongolian</code></td>
      <td><code class="literal">Myanmar</code></td>
      <td><code class="literal">New_Tai_Lue</code></td>
     </tr>

     <tr>
      <td><code class="literal">Nko</code></td>
      <td><code class="literal">Ogham</code></td>
      <td><code class="literal">Old_Italic</code></td>
      <td><code class="literal">Old_Persian</code></td>
      <td><code class="literal">Old_South_Arabian</code></td>
     </tr>

     <tr>
      <td><code class="literal">Old_Turkic</code></td>
      <td><code class="literal">Ol_Chiki</code></td>
      <td><code class="literal">Oriya</code></td>
      <td><code class="literal">Osmanya</code></td>
      <td><code class="literal">Phags_Pa</code></td>
     </tr>

     <tr>
      <td><code class="literal">Phoenician</code></td>
      <td><code class="literal">Rejang</code></td>
      <td><code class="literal">Runic</code></td>
      <td><code class="literal">Samaritan</code></td>
      <td><code class="literal">Saurashtra</code></td>
     </tr>

     <tr>
      <td><code class="literal">Sharada</code></td>
      <td><code class="literal">Shavian</code></td>
      <td><code class="literal">Sinhala</code></td>
      <td><code class="literal">Sora_Sompeng</code></td>
      <td><code class="literal">Sundanese</code></td>
     </tr>

     <tr>
      <td><code class="literal">Syloti_Nagri</code></td>
      <td><code class="literal">Syriac</code></td>
      <td><code class="literal">Tagalog</code></td>
      <td><code class="literal">Tagbanwa</code></td>
      <td><code class="literal">Tai_Le</code></td>
     </tr>

     <tr>
      <td><code class="literal">Tai_Tham</code></td>
      <td><code class="literal">Tai_Viet</code></td>
      <td><code class="literal">Takri</code></td>
      <td><code class="literal">Tamil</code></td>
      <td><code class="literal">Telugu</code></td>
     </tr>

     <tr>
      <td><code class="literal">Thaana</code></td>
      <td><code class="literal">Thai</code></td>
      <td><code class="literal">Tibetan</code></td>
      <td><code class="literal">Tifinagh</code></td>
      <td><code class="literal">Ugaritic</code></td>
     </tr>

     <tr>
      <td><code class="literal">Vai</code></td>
      <td><code class="literal">Yi</code></td>
      <td class="empty"> </td>
      <td class="empty"> </td>
      <td class="empty"> </td>
     </tr>

    </tbody>
   
  </table>

  <p class="para">
   La secuencia de escape <code class="literal">\X</code> coincide con un grupo de glifos extendidos de Unicode. Un grupo de glifos extendidos de Unicode es uno o más caracteres Unicode
   que se combinan para formar un glifo. En efecto, esto puede considerarse como
   el equivalente de Unicode de <code class="literal">.</code> ya que coincidirá con un
   carácter compuesto, independientemente de cuántos caracteres individuales se
   utilicen realmente para renderizarlo.
  </p>
  <p class="para">
   En versiones de PCRE anteriores a 8.32 (que corresponde a versiones de PHP anteriores a 5.4.14 cuando se usa la biblioteca PCRE incluida), <code class="literal">\X</code>
   es equivalente a <code class="literal">(?&gt;\PM\pM*)</code>. Es decir, coincide con un carácter sin la propiedad "marca", seguido de cero o más caracteres
   con la propiedad "marca", y trata la secuencia como un grupo atómico (ver más abajo). Los caracteres con la propiedad "marca" son típicamente acentos que afectan al carácter anterior.
  </p>
  <p class="para">
   Coincidir con caracteres por propiedad Unicode no es rápido, porque PCRE tiene
   que buscar una estructura que contiene datos para más de quince mil
   caracteres. Por eso las secuencias de escape tradicionales como
   <code class="literal">\d</code> y <code class="literal">\w</code> no usan propiedades Unicode
   en PCRE.
  </p>
 </div>
<hr>


 <div id="regexp.reference.anchors" class="section"><hr>
  <h2 class="title">Anclajes</h2>
  <p class="para">
   Fuera de una clase de caracteres, en el modo de coincidencia predeterminado, el
   carácter de circunflejo (<code class="literal">^</code>) es una afirmación que
   es verdadera solo si el punto de coincidencia actual está al inicio
   de la cadena de sujeto. Dentro de una clase de caracteres, el circunflejo (<code class="literal">^</code>)
   tiene un significado completamente diferente (ver más abajo).
  </p>
  <p class="para">
   El circunflejo (<code class="literal">^</code>) no necesita ser el primer carácter
   del patrón si se involucran varias alternativas, pero
   debe ser la primera cosa en cada alternativa en la que aparezca
   si el patrón alguna vez va a coincidir con esa rama. Si todas las alternativas posibles comienzan con un circunflejo (<code class="literal">^</code>), es decir,
   si el patrón está restringido a coincidir solo al inicio del sujeto,
   se dice que está "anclado". (También hay otras
   construcciones que pueden causar que un patrón esté anclado.)
  </p>
  <p class="para">
   Un carácter de dólar (<code class="literal">$</code>) es una afirmación que es
   <strong><code><a href="#constant.true">true</a></code></strong> solo si el punto de coincidencia actual está al final
   de la cadena de sujeto, o inmediatamente antes de un carácter de nueva línea que es el último
   carácter en la cadena (por defecto). El dólar (<code class="literal">$</code>)
   no necesita ser el último carácter del patrón si se involucran varias alternativas, pero
   debe ser el último elemento en cualquier rama
   en la que aparezca. El dólar no tiene ningún significado especial en una
   clase de caracteres.
  </p>
  <p class="para">
   El significado del dólar puede cambiarse para que solo coincida
   al final muy exacto de la cadena, estableciendo la
   <a href="#reference.pcre.pattern.modifiers" class="link">opción PCRE_DOLLAR_ENDONLY</a>
   en el momento de compilación o coincidencia. Esto no afecta la afirmación \Z.
  </p>
  <p class="para">
   Los significados de los caracteres de circunflejo y dólar cambian si la
   <a href="#reference.pcre.pattern.modifiers" class="link">opción PCRE_MULTILINE</a> está establecida. Cuando esto es así, coinciden inmediatamente después y
   inmediatamente antes de un carácter "\n" interno, respectivamente, además de coincidir al inicio y final de la cadena de sujeto. Por ejemplo, el patrón /^abc$/ coincide con la cadena de sujeto "def\nabc" en modo multiline,
   pero no de otra manera. Por lo tanto, los patrones que están anclados en modo de una sola línea porque todas las ramas comienzan con "^" no están anclados en modo multiline. La
   <a href="#reference.pcre.pattern.modifiers" class="link">opción PCRE_DOLLAR_ENDONLY</a>
   se ignora si
   <a href="#reference.pcre.pattern.modifiers" class="link">PCRE_MULTILINE</a> está
   establecido.
  </p>
  <p class="para">
   Tenga en cuenta que las secuencias \A, \Z y \z pueden usarse para coincidir
   con el inicio y final del sujeto en ambos modos, y si todas
   las ramas de un patrón comienzan con \A, siempre está anclado,
   ya sea que <a href="#reference.pcre.pattern.modifiers" class="link">PCRE_MULTILINE</a>
   esté establecido o no.
  </p>
 </div>
<hr>


 <div id="regexp.reference.dot" class="section"><hr>
  <h2 class="title">Punto</h2>
  <p class="para">
   Fuera de una clase de caracteres, un punto en el patrón coincide con cualquier
   carácter en el sujeto, incluyendo un carácter no imprimible,
   pero no (por defecto) un salto de línea. Si la
   <a href="#reference.pcre.pattern.modifiers" class="link">opción PCRE_DOTALL</a> está establecida, entonces los puntos coinciden con saltos de línea también. El
   manejo del punto es completamente independiente del manejo de circunflejo y dólar, la única relación siendo que ambos involucran caracteres de salto de línea. El punto no tiene ningún significado especial
   en una clase de caracteres.
  </p>
  <p class="para">
   <em>\C</em> puede usarse para coincidir con un solo byte. Tiene sentido
   en <em>modo UTF-8</em> donde el punto completo coincide con el carácter completo que puede consistir en múltiples bytes.
  </p>
 </div>
<hr>


 <div id="regexp.reference.character-classes" class="section"><hr>
  <h2 class="title">Clases de caracteres</h2>
  <p class="para">
   Un corchete de apertura introduce una clase de caracteres,
   terminada por un corchete de cierre. Un corchete de cierre por sí solo no es especial. Si se requiere un corchete de cierre como miembro de la clase, debe ser
   el primer carácter de datos en la clase (después de un circunflejo inicial, si está presente) o escapado con una barra invertida.
  </p>
  <p class="para">
   Una clase de caracteres coincide con un solo carácter en el sujeto;
   el carácter debe estar en el conjunto de caracteres definido por
   la clase, a menos que el primer carácter en la clase sea un
   circunflejo, en cuyo caso el carácter del sujeto no debe estar en
   el conjunto definido por la clase. Si se requiere un circunflejo como
   miembro de la clase, asegúrese de que no sea el
   primer carácter, o escápelo con una barra invertida.
  </p>
  <p class="para">
   Por ejemplo, la clase de caracteres [aeiou] coincide con cualquier vocal minúscula, mientras que [^aeiou] coincide con cualquier carácter que no sea
   una vocal minúscula. Tenga en cuenta que un circunflejo es solo una
   notación conveniente para especificar los caracteres que están en
   la clase enumerando aquellos que no están. No es una
   afirmación: aún consume un carácter de la cadena de sujeto,
   y falla si el puntero actual está al final
   de la cadena.
  </p>
  <p class="para">
   Cuando se establece la coincidencia sin distinción de mayúsculas y minúsculas, cualquier letra
   en una clase representa tanto su versión mayúscula como minúscula,
   por lo que, por ejemplo, una [aeiou] insensible coincide con "A"
   así como con "a", y una [^aeiou] insensible no coincide
   con "A", mientras que una versión sensible (con distinción de mayúsculas y minúsculas) sí.
  </p>
  <p class="para">
   El carácter de nueva línea nunca se trata de manera especial en
   clases de caracteres, independientemente de la configuración de las opciones <a href="#reference.pcre.pattern.modifiers" class="link">PCRE_DOTALL</a>
   o <a href="#reference.pcre.pattern.modifiers" class="link">PCRE_MULTILINE</a>. Una clase como [^a] siempre coincide con una nueva línea.
  </p>
  <p class="para">
   El carácter de guión puede usarse para especificar un rango
   de caracteres en una clase de caracteres. Por ejemplo, [d-m]
   coincide con cualquier letra entre d y m, inclusive. Si se requiere un carácter de guión en una clase, debe escaparse con una
   barra invertida o aparecer en una posición donde no pueda
   interpretarse como indicación de un rango, típicamente como el primer o último
   carácter en la clase.
  </p>
  <p class="para">
   No es posible tener el carácter literal "]" como el
   carácter final de un rango. Un patrón como [W-]46] es
   interpretado como una clase de dos caracteres ("W" y "-")
   seguido de una cadena literal "46]", por lo que coincidiría con "W46]" o
   "-46]". Sin embargo, si el "]" se escapa con una barra invertida, se interpreta como el final del rango, por lo que [W-\]46] es
   interpretado como una sola clase que contiene un rango seguido de dos
   caracteres separados. También se puede usar la representación octal o hexadecimal
   de "]" para terminar un rango.
  </p>
  <p class="para">
   Los rangos operan en la secuencia de clasificación ASCII. También pueden usarse para caracteres especificados numéricamente, por ejemplo
   [\000-\037]. Si se usa un rango que incluye letras cuando se establece la
   coincidencia sin distinción de mayúsculas y minúsculas, coincide con
   las letras en cualquier caso. Por ejemplo, [W-c] es equivalente a
   [][\^_`wxyzabc], coincidiendo sin distinción de mayúsculas y minúsculas, y si se usan tablas de caracteres para la configuración regional "fr", [\xc8-\xcb] coincide
   con caracteres E acentuados en ambos casos.
  </p>
  <p class="para">
   Los tipos de caracteres \d, \D, \s, \S, \w, y \W también
   pueden aparecer en una clase de caracteres, y añaden los caracteres que
   coinciden a la clase. Por ejemplo, [\dABCDEF] coincide con cualquier
   dígito hexadecimal. Un circunflejo puede usarse convenientemente
   con los tipos de caracteres mayúsculas para especificar un conjunto más
   restringido de caracteres que el tipo minúscula correspondiente.
   Por ejemplo, la clase [^\W_] coincide con cualquier letra o dígito,
   pero no con el guión bajo.
  </p>
  <p class="para">
   Todos los caracteres no alfanuméricos excepto \, -, ^ (al inicio) y el terminador ] son no especiales en clases de caracteres, pero no causa daño si están escapados. El terminador del patrón es siempre especial y debe escaparse cuando se usa
   dentro de una expresión.
  </p>
  <p class="para">
   Perl soporta la notación POSIX para clases de caracteres. Esta usa nombres
   encerrados por <code class="literal">[:</code> y <code class="literal">:]</code> dentro
   de los corchetes de apertura y cierre. PCRE también
   soporta esta notación. Por ejemplo, <code class="literal">[01[:alpha:]%]</code>
   coincide con "0", "1", cualquier carácter alfabético, o "%". Las clases de nombres soportadas son:
   </p><table class="doctable table">
    <caption><strong>Clases de caracteres</strong></caption>
    
     <tbody class="tbody">
      <tr><td><code class="literal">alnum</code></td><td>letras y dígitos</td></tr>

      <tr><td><code class="literal">alpha</code></td><td>letras</td></tr>

      <tr><td><code class="literal">ascii</code></td><td>códigos de caracteres 0 - 127</td></tr>

      <tr><td><code class="literal">blank</code></td><td>solo espacio o tabulación</td></tr>

      <tr><td><code class="literal">cntrl</code></td><td>caracteres de control</td></tr>

      <tr><td><code class="literal">digit</code></td><td>dígitos decimales (igual que \d)</td></tr>

      <tr><td><code class="literal">graph</code></td><td>caracteres de impresión, excluyendo espacio</td></tr>

      <tr><td><code class="literal">lower</code></td><td>letras minúsculas</td></tr>

      <tr><td><code class="literal">print</code></td><td>caracteres de impresión, incluyendo espacio</td></tr>

      <tr><td><code class="literal">punct</code></td><td>caracteres de impresión, excluyendo letras y dígitos</td></tr>

      <tr><td><code class="literal">space</code></td><td>espacio en blanco (no exactamente igual que \s)</td></tr>

      <tr><td><code class="literal">upper</code></td><td>letras mayúsculas</td></tr>

      <tr><td><code class="literal">word</code></td><td>caracteres de "palabra" (igual que \w)</td></tr>

      <tr><td><code class="literal">xdigit</code></td><td>dígitos hexadecimales</td></tr>

     </tbody>
    
   </table>

   Los caracteres <code class="literal">space</code> son HT (9), LF (10), VT (11), FF (12), CR (13),
   y espacio (32). Observe que esta lista incluye el carácter VT (código
   11). Esto hace que "space" sea diferente a <code class="literal">\s</code>, que no incluye VT (para compatibilidad con Perl).
  
  <p class="para">
   El nombre <code class="literal">word</code> es una extensión de Perl, y <code class="literal">blank</code> es una extensión de GNU
   de Perl 5.8. Otra extensión de Perl es la negación, que se indica
   con un carácter <code class="literal">^</code> después de los dos puntos. Por ejemplo,
   <code class="literal">[12[:^digit:]]</code> coincide con "1", "2", o cualquier no dígito.
  </p>
  <p class="para">
   En modo UTF-8, los caracteres con valores mayores que 128 no coinciden con ninguna
   de las clases de caracteres POSIX.
   A partir de libpcre 8.10, algunas clases de caracteres se cambian para usar
   propiedades de caracteres Unicode, en cuyo caso la restricción mencionada no se aplica. Consulte el <a href="http://www.pcre.org/pcre.txt" class="link external">» manual PCRE(3)</a>
   para obtener más detalles.
  </p>
  <p class="para">
   Las propiedades de caracteres Unicode pueden aparecer dentro de una clase de caracteres. No pueden ser parte de un rango. El carácter de guión después de una clase de caracteres Unicode coincidirá literalmente. Intentar terminar un rango con una propiedad de caracteres Unicode resultará en una advertencia.
  </p>
 </div>
<hr>


 <div id="regexp.reference.alternation" class="section"><hr>
  <h2 class="title">Alternancia</h2>
  <p class="para">
   Los caracteres de barra vertical se usan para separar patrones alternativos.
   Por ejemplo, el patrón
   <code class="literal">gilbert|sullivan</code>
   coincide con "gilbert" o "sullivan". Cualquier número de alternativas
   puede aparecer, y se permite una alternativa vacía
   (coincidiendo con la cadena vacía). El proceso de coincidencia intenta
   cada alternativa en orden, de izquierda a derecha, y la primera
   que tenga éxito se usa. Si las alternativas están dentro de un
   subpatrón (definido más abajo), "éxito" significa coincidir con
   el resto del patrón principal así como con la alternativa en el
   subpatrón.
  </p>
  <p class="para">
   Es posible registrar cuál alternativa fue coincidente usando
   <code class="literal">(*MARK:NAME)</code> o <code class="literal">(*:NAME)</code>.
   Cualquier número de verbos <code class="literal">(*MARK)</code> pueden aparecer y sus nombres no tienen que ser únicos. Cuando una coincidencia tiene éxito, el nombre de la última <code class="literal">(*MARK:NAME)</code> encontrada se colocará entre las coincidencias como si fuera un grupo de captura llamado <code class="literal">MARK</code> para que pueda leerse desde el <code class="parameter">matches</code> de
   <span class="function"><a href="#function.preg-match" class="function">preg_match()</a></span> y se pasará al
   <code class="parameter">callback</code> de <span class="function"><a href="#function.preg-replace-callback" class="function">preg_replace_callback()</a></span> etc.
  </p>
 </div>
<hr>


 <div id="regexp.reference.internal-options" class="section"><hr>
  <h2 class="title">Configuración de opciones internas</h2>
  <p class="para">
   La configuración de <a href="#reference.pcre.pattern.modifiers" class="link">PCRE_CASELESS</a>,
   <a href="#reference.pcre.pattern.modifiers" class="link">PCRE_MULTILINE</a>,
   <a href="#reference.pcre.pattern.modifiers" class="link">PCRE_DOTALL</a>,
   <a href="#reference.pcre.pattern.modifiers" class="link">PCRE_UNGREEDY</a>,
   <a href="#reference.pcre.pattern.modifiers" class="link">PCRE_EXTRA</a>,
   <a href="#reference.pcre.pattern.modifiers" class="link">PCRE_EXTENDED</a>
   y PCRE_DUPNAMES puede cambiarse desde dentro del patrón mediante
   una secuencia de letras de opciones de Perl encerradas entre "(?" y
   ")". Las letras de opciones son:

   </p><table class="doctable table">
    <caption><strong>Letras de opciones internas</strong></caption>
    
     <tbody class="tbody">
      <tr>
       <td><code class="literal">i</code></td>
       <td>para <a href="#reference.pcre.pattern.modifiers" class="link">PCRE_CASELESS</a></td>
      </tr>

      <tr>
       <td><code class="literal">m</code></td>
       <td>para <a href="#reference.pcre.pattern.modifiers" class="link">PCRE_MULTILINE</a></td>
      </tr>

      <tr>
       <td><code class="literal">s</code></td>
       <td>para <a href="#reference.pcre.pattern.modifiers" class="link">PCRE_DOTALL</a></td>
      </tr>

      <tr>
       <td><code class="literal">x</code></td>
       <td>para <a href="#reference.pcre.pattern.modifiers" class="link">PCRE_EXTENDED</a></td>
      </tr>

      <tr>
       <td><code class="literal">U</code></td>
       <td>para <a href="#reference.pcre.pattern.modifiers" class="link">PCRE_UNGREEDY</a></td>
      </tr>

      <tr>
       <td><code class="literal">X</code></td>
       <td>para <a href="#reference.pcre.pattern.modifiers" class="link">PCRE_EXTRA</a>
        (ya no soportado a partir de PHP 7.3.0)</td>
      </tr>

      <tr>
       <td><code class="literal">J</code></td>
       <td>para <a href="#reference.pcre.pattern.modifiers" class="link">PCRE_INFO_JCHANGED</a></td>
      </tr>

     </tbody>
    
   </table>

  
  <p class="para">
   Por ejemplo, (?im) establece coincidencia sin distinción de mayúsculas y minúsculas, multiline. También es posible anular estas opciones precediendo la letra
   con un guión, y una configuración combinada como
   (?im-sx), que establece <a href="#reference.pcre.pattern.modifiers" class="link">PCRE_CASELESS</a> y
   <a href="#reference.pcre.pattern.modifiers" class="link">PCRE_MULTILINE</a>
   mientras anula <a href="#reference.pcre.pattern.modifiers" class="link">PCRE_DOTALL</a> y
   <a href="#reference.pcre.pattern.modifiers" class="link">PCRE_EXTENDED</a>,
   también está permitido. Si una letra aparece tanto antes como después del
   guión, la opción se anula.
  </p>
  <p class="para">
   Cuando ocurre un cambio de opción a nivel superior (es decir, no dentro
   de paréntesis de subpatrón), el cambio se aplica al resto del
   patrón que sigue. Por lo tanto, <code class="literal">/ab(?i)c/</code> coincide solo con "abc"
   y "abC".
  </p>
  <p class="para">
   Si un cambio de opción ocurre dentro de un subpatrón, el efecto
   es diferente. Este es un cambio de comportamiento en Perl 5.005.
   Un cambio de opción dentro de un subpatrón afecta solo a esa parte
   del subpatrón que sigue, por lo que

   <code class="literal">(a(?i)b)c</code>

   coincide con "abc" y "aBc" y ninguna otra cadena (asumiendo <a href="#reference.pcre.pattern.modifiers" class="link">PCRE_CASELESS</a> no se usa). De esta manera, las opciones pueden tener diferentes configuraciones en
   diferentes partes del patrón. Cualquier cambio realizado en una alternativa se
   lleva a las ramas posteriores dentro del mismo subpatrón. Por
   ejemplo,

   <code class="literal">(a(?i)b|c)</code>

   coincide con "ab", "aB", "c", y "C", incluso cuando se coincide
   con "C" la primera rama se abandona antes de la configuración de la opción.
   Esto se debe a que los efectos de la configuración de las opciones ocurren al
   tiempo de compilación. Habría un comportamiento muy extraño de otra manera.
  </p>
  <p class="para">
   Las opciones específicas de PCRE <a href="#reference.pcre.pattern.modifiers" class="link">PCRE_UNGREEDY</a> y
   <a href="#reference.pcre.pattern.modifiers" class="link">PCRE_EXTRA</a> pueden
   cambiarse de la misma manera que las opciones compatibles con Perl usando las letras U y X respectivamente. La configuración de la bandera
   (?X) es especial en que siempre debe ocurrir antes en
   el patrón que cualquiera de las características adicionales que activa,
   incluso cuando está a nivel superior. Es mejor ponerla al principio.
  </p>
 </div>
<hr>


 <div id="regexp.reference.subpatterns" class="section"><hr>
  <h2 class="title">Subpatrones</h2>
  <p class="para">
   Los subpatrones están delimitados por paréntesis (paréntesis redondos),
   que pueden anidarse. Marcar una parte de un patrón como subpatrón
   hace dos cosas:
  </p>
  <ol type="1">
   <li class="listitem">
    <p class="para">
     Localiza un conjunto de alternativas. Por ejemplo, el patrón
     <code class="literal">cat(aract|erpillar|)</code> coincide con una de las palabras "cat",
     "cataract", o "caterpillar". Sin los paréntesis, coincidiría
     con "cataract", "erpillar" o la cadena vacía.
    </p>
   </li>
   <li class="listitem">
    <p class="para">
     Establece el subpatrón como un subpatrón de captura (como se definió anteriormente).
     Cuando todo el patrón coincide, la porción de la cadena de sujeto
     que coincidió con el subpatrón se devuelve al llamador a través del
     argumento <em>ovector</em> de <span class="function"><strong>pcre_exec()</strong></span>.
     Los paréntesis de apertura se cuentan de izquierda a derecha (comenzando desde 1) para
     obtener los números de los subpatrones de captura.
    </p>
   </li>
  </ol>
  <p class="para">
   Por ejemplo, si la cadena "the red king" se compara con
   el patrón

   <code class="literal">the ((red|white) (king|queen))</code>

   las subcadenas capturadas son "red king", "red", y "king",
   y están numeradas 1, 2, y 3.
  </p>
  <p class="para">
   El hecho de que los paréntesis simples cumplan dos funciones no
   siempre es útil. Hay momentos en los que se requiere un subpatrón de agrupación
   sin un requisito de captura. Si un paréntesis de apertura es seguido por "?:", el subpatrón no
   realiza ninguna captura, y no se cuenta al calcular el número de cualquier subpatrón de captura posterior. Por ejemplo, si la cadena "the white queen" se compara con
   el patrón

   <code class="literal">the ((?:red|white) (king|queen))</code>

   las subcadenas capturadas son "white queen" y "queen", y
   están numeradas 1 y 2. El número máximo de subcadenas capturadas
   es 65535. Puede que no sea posible compilar patrones tan grandes,
   sin embargo, dependiendo de las opciones de configuración de libpcre.
  </p>
  <p class="para">
   Como abreviatura conveniente, si se requieren configuraciones de opciones
   al inicio de un subpatrón no de captura, las letras de opciones pueden aparecer entre
   el "?" y el ":". Por lo tanto, los dos patrones
  </p>

  <div class="informalexample">
   <div class="example-contents">
<div class="annotation-interactive cdata"><pre>
(?i:saturday|sunday)
(?:(?i)saturday|sunday)
</pre></div>
   </div>

  </div>

  <p class="para">
   coinciden exactamente con el mismo conjunto de cadenas. Debido a que las ramas alternativas se prueban de izquierda a derecha, y las opciones no se restablecen hasta que se alcanza el final del subpatrón, una configuración de opción en una rama afecta a las ramas posteriores, por lo que los patrones anteriores coinciden con "SUNDAY" así como con "Saturday".
  </p>

  <p class="para">
   Es posible nombrar un subpatrón usando la sintaxis
   <code class="literal">(?P&lt;name&gt;pattern)</code>. Este subpatrón luego
   será indexado en el array de coincidencias por su posición numérica normal y
   también por nombre. Hay dos sintaxis alternativas
   <code class="literal">(?&lt;name&gt;pattern)</code> y <code class="literal">(?'name'pattern)</code>.
  </p>

  <p class="para">
   A veces es necesario tener múltiples coincidencias alternativas
   en una expresión regular. Normalmente, cada una de estas tendría
   su propio número de referencia inversa, aunque solo una de ellas podría coincidir.
   Para superar esto, la sintaxis <code class="literal">(?|</code> permite tener números duplicados. Considere el siguiente regex aplicado a la cadena <code class="literal">Sunday</code>:
  </p>

  <div class="informalexample">
   <div class="example-contents">
<div class="annotation-interactive cdata"><pre>(?:(Sat)ur|(Sun))day</pre></div>
   </div>

  </div>

  <p class="para">
   Aquí <code class="literal">Sun</code> se almacena en la referencia inversa 2, mientras que
   la referencia inversa 1 está vacía. Hacer coincidir <code class="literal">Saturday</code> produce
   <code class="literal">Sat</code> en la referencia inversa 1 mientras que la referencia inversa 2 no existe. Cambiar el patrón para usar <code class="literal">(?|</code> resuelve este problema:
  </p>

  <div class="informalexample">
   <div class="example-contents">
<div class="annotation-interactive cdata"><pre>(?|(Sat)ur|(Sun))day</pre></div>
   </div>

  </div>

  <p class="para">
   Usando este patrón, tanto <code class="literal">Sun</code> como <code class="literal">Sat</code>
   se almacenarían en la referencia inversa 1.
  </p>
 </div>
<hr>


 <div id="regexp.reference.repetition" class="section"><hr>
  <h2 class="title">Repetición</h2>
  <p class="para">
   La repetición se especifica mediante cuantificadores, que pueden seguir cualquiera
   de los siguientes elementos:

   </p><ul class="itemizedlist">
    <li class="listitem"><span class="simpara">un solo carácter, posiblemente escapado</span></li>
    <li class="listitem"><span class="simpara">el metacarácter .</span></li>
    <li class="listitem"><span class="simpara">una clase de caracteres</span></li>
    <li class="listitem"><span class="simpara">una referencia inversa (ver siguiente sección)</span></li>
    <li class="listitem"><span class="simpara">un subpatrón entre paréntesis (a menos que sea una afirmación -
     ver más abajo)</span></li>
   </ul>
  
  <p class="para">
   El cuantificador general de repetición especifica un número mínimo y máximo de coincidencias permitidas, dando los dos
   números entre llaves (llaves), separados por una coma.
   Los números deben ser menores que 65536, y el primero debe ser
   menor o igual al segundo. Por ejemplo:

   <code class="literal">z{2,4}</code>

   coincide con "zz", "zzz", o "zzzz". Una llave de cierre por sí sola
   no es un carácter especial. Si el segundo número se omite,
   pero la coma está presente, no hay límite superior; si el
   segundo número y la coma se omiten ambos, el cuantificador
   especifica un número exacto de coincidencias requeridas. Por lo tanto

   <code class="literal">[aeiou]{3,}</code>

   coincide con al menos 3 vocales sucesivas, pero puede coincidir con
   muchas más, mientras que

   <code class="literal">\d{8}</code>

   coincide con exactamente 8 dígitos.

  </p>
  <p class="simpara">
   Antes de PHP 8.4.0, una llave de apertura que
   aparece en una posición donde no se permite un cuantificador, o
   una que no coincide con la sintaxis de un cuantificador, se toma
   como un carácter literal. Por ejemplo, <code class="literal">{,6}</code>
   no es un cuantificador, sino una cadena literal de cuatro caracteres.

   A partir de PHP 8.4.0, la extensión PCRE se incluye con la versión PCRE2 10.44,
   que permite patrones como <code class="literal">\d{,8}</code> y se interpretan como <code class="literal">\d{0,8}</code>.

   Además, a partir de PHP 8.4.0, los caracteres de espacio alrededor de los cuantificadores como
   <code class="literal">\d{0 , 8}</code> y <code class="literal">\d{ 0 , 8 }</code> están permitidos.
  </p>
  <p class="para">
   El cuantificador {0} está permitido, lo que hace que la expresión se comporte como si el elemento anterior y el cuantificador no estuvieran presentes.
  </p>
  <p class="para">
   Para mayor comodidad (y compatibilidad histórica) los tres cuantificadores más comunes tienen abreviaturas de un solo carácter:

   </p><table class="doctable table">
    <caption><strong>Cuantificadores de un solo carácter</strong></caption>
    
     <tbody class="tbody">
      <tr>
       <td><code class="literal">*</code></td>
       <td>equivalente a <code class="literal">{0,}</code></td>
      </tr>

      <tr>
       <td><code class="literal">+</code></td>
       <td>equivalente a <code class="literal">{1,}</code></td>
      </tr>

      <tr>
       <td><code class="literal">?</code></td>
       <td>equivalente a <code class="literal">{0,1}</code></td>
      </tr>

     </tbody>
    
   </table>

  
  <p class="para">
   Es posible construir bucles infinitos siguiendo un subpatrón que puede coincidir con cero caracteres con un cuantificador que no tiene límite superior, por ejemplo:

   <code class="literal">(a?)*</code>
  </p>
  <p class="para">
   Versiones anteriores de Perl y PCRE solían dar un error en el momento de la compilación para tales patrones. Sin embargo, dado que hay casos en los que esto puede ser útil, tales patrones ahora son aceptados, pero si alguna repetición del subpatrón en realidad coincide con cero caracteres, el bucle se rompe a la fuerza.
  </p>
  <p class="para">
   Por defecto, los cuantificadores son "codiciosos", es decir, coinciden con la mayor cantidad posible (hasta el número máximo de veces permitido), sin causar que el resto del patrón
   falle. El ejemplo clásico donde esto causa problemas es al intentar coincidir con comentarios en programas C. Estos aparecen entre
   las secuencias /* y */ y dentro de la secuencia, los caracteres individuales
   * y / pueden aparecer. Un intento de coincidir con comentarios C aplicando el patrón

   <code class="literal">/\*.*\*/</code>

   a la cadena

   <code class="literal">/* first comment */ not comment /* second comment */</code>

   falla, porque coincide con toda la cadena debido a la codicia del elemento .*.
  </p>
  <p class="para">
   Sin embargo, si un cuantificador es seguido por un signo de interrogación,
   entonces se vuelve perezoso, y en su lugar coincide con el número mínimo de veces posible, por lo que el patrón

   <code class="literal">/\*.*?\*/</code>

   hace lo correcto con los comentarios C. El significado de los varios cuantificadores no cambia de otra manera, solo el número preferido de coincidencias. No confunda este uso de
   signo de interrogación con su uso como cuantificador por sí mismo.
   Debido a que tiene dos usos, a veces puede aparecer duplicado, como en

   <code class="literal">\d??\d</code>

   que coincide con un dígito por preferencia, pero puede coincidir con dos si
   esa es la única manera de que el resto del patrón coincida.
  </p>
  <p class="para">
   Si la <a href="#reference.pcre.pattern.modifiers" class="link">opción PCRE_UNGREEDY</a>
   está establecida (una opción que no
   está disponible en Perl) entonces los cuantificadores no son codiciosos por defecto, pero los individuales pueden hacerse codiciosos siguiendo
   con un signo de interrogación. En otras palabras, invierte el comportamiento por defecto.
  </p>
  <p class="para">
   Los cuantificadores seguidos de <code class="literal">+</code> son "poseídos". Consumen
   tantos caracteres como sea posible y no regresan para hacer coincidir el resto del
   patrón. Por lo tanto, <code class="literal">.*abc</code> coincide con "aabc" pero
   <code class="literal">.*+abc</code> no porque <code class="literal">.*+</code> consume toda la cadena. Los cuantificadores poseídos pueden usarse para acelerar el procesamiento.
  </p>
  <p class="para">
   Cuando un subpatrón entre paréntesis se cuantifica con un conteo de repetición mínimo que es mayor que 1 o con un máximo limitado,
   se requiere más almacenamiento para el patrón compilado, en
   proporción al tamaño del mínimo o máximo.
  </p>
  <p class="para">
   Si un patrón comienza con .* o .{0,} y la <a href="#reference.pcre.pattern.modifiers" class="link">opción PCRE_DOTALL</a> está establecida (equivalente a /s de Perl), lo que permite que el punto coincida con saltos de línea, entonces el patrón está implícitamente anclado,
   porque lo que sigue se intentará contra cada posición de carácter en la cadena de sujeto, por lo que no tiene sentido volver a intentar la coincidencia general en cualquier posición después de la primera.
   PCRE trata un patrón como si estuviera precedido por \A.
   En casos donde se sabe que la cadena de sujeto no contiene saltos de línea, se obtiene una optimización estableciendo <a href="#reference.pcre.pattern.modifiers" class="link">PCRE_DOTALL</a> cuando el patrón comienza con .* para
   obtener esta optimización, o
   alternativamente usando ^ para indicar el anclaje explícitamente.
  </p>
  <p class="para">
   Cuando un subpatrón de captura se repite, el valor capturado es la subcadena que coincidió con la iteración final. Por ejemplo, después de

   <code class="literal">(tweedle[dume]{3}\s*)+</code>

   ha coincidido con "tweedledum tweedledee" el valor de la subcadena capturada es "tweedledee". Sin embargo, si hay
   subpatrones de captura anidados, los valores capturados correspondientes pueden haber sido establecidos en iteraciones anteriores. Por ejemplo,
   después de

   <code class="literal">/(a|(b))+/</code>

   coincide con "aba" el valor de la segunda subcadena capturada es
   "b".
  </p>
 </div>
<hr>


 <div id="regexp.reference.back-references" class="section"><hr>
  <h2 class="title">Referencias inversas</h2>
  <p class="para">
   Fuera de una clase de caracteres, una barra invertida seguida de un dígito
   mayor que 0 (y posiblemente otros dígitos) es una referencia inversa a un subpatrón de captura anterior (es decir, a su
   izquierda) en el patrón, siempre que haya habido tantos subpatrones de apertura de captura anteriores.
  </p>
  <p class="para">
   Sin embargo, si el número decimal que sigue a la barra invertida es
   menor que 10, siempre se toma como una referencia inversa, y causa un error solo si no hay tantos paréntesis de apertura de captura en todo el patrón. En otras palabras, los
   paréntesis a los que se hace referencia no necesitan estar a la izquierda de la referencia para números menores que 10.
   Una "referencia inversa hacia adelante" puede tener sentido cuando se involucra una repetición y el subpatrón a la derecha ha participado
   en una iteración anterior. Consulte la sección
   <a href="#regexp.reference.escape" class="link">secuencias de escape</a> para obtener más detalles sobre el manejo de los dígitos que siguen a una barra invertida.
  </p>
  <p class="para">
   Una referencia inversa coincide con lo que realmente coincidió con el subpatrón de captura en la cadena de sujeto actual, en lugar de
   cualquier cosa que coincida con el subpatrón mismo. Por lo tanto, el patrón

   <code class="literal">(sens|respons)e and \1ibility</code>

   coincide con "sense and sensibility" y "response and responsibility",
   pero no con "sense and responsibility". Si la coincidencia sensible (con distinción de mayúsculas y minúsculas) está en vigor en el momento de la referencia inversa, entonces
   el caso de las letras es relevante. Por ejemplo,

   <code class="literal">((?i)rah)\s+\1</code>

   coincide con "rah rah" y "RAH RAH", pero no con "RAH rah", incluso
   aunque el subpatrón de captura original se coincidió sin distinción de mayúsculas y minúsculas.
  </p>
  <p class="para">
   Puede haber más de una referencia inversa al mismo subpatrón.
   Si un subpatrón no se ha utilizado realmente en
   una coincidencia particular, entonces cualquier referencia inversa a él siempre
   falla. Por ejemplo, el patrón

   <code class="literal">(a|(bc))\2</code>

   siempre falla si comienza a coincidir con "a" en lugar de "bc".
   Debido a que pueden haber hasta 99 referencias inversas, todos los dígitos
   que siguen a la barra invertida se toman como parte de un número de referencia inversa potencial. Si el patrón continúa con un carácter de dígito,
   entonces algún delimitador debe usarse para terminar la referencia inversa. Si la <a href="#reference.pcre.pattern.modifiers" class="link">opción PCRE_EXTENDED</a> está establecida, esto puede ser espacio en blanco. De lo contrario, se puede usar un comentario vacío.
  </p>
  <p class="para">
   Una referencia inversa que ocurre dentro de los paréntesis a los que se refiere falla cuando el subpatrón se usa por primera vez, por lo que, por
   ejemplo, (a\1) nunca coincide. Sin embargo, tales referencias pueden ser útiles dentro de subpatrones repetidos. Por ejemplo, el patrón

   <code class="literal">(a|b\1)+</code>

   coincide con cualquier número de "a" y también "aba", "ababba" etc. En cada iteración del subpatrón, la referencia inversa coincide
   con la cadena de caracteres correspondiente a la iteración anterior.
   Para que esto funcione, el patrón debe ser tal
   que la primera iteración no necesite coincidir con la referencia inversa. Esto se puede hacer usando alternancia, como en el
   ejemplo anterior, o por un cuantificador con un mínimo de cero.
  </p>
  <p class="para">
   La secuencia de escape <code class="literal">\g</code> puede usarse para referencias absolutas y relativas de subpatrones.
   Esta secuencia de escape debe ir seguida de un número sin signo o un número negativo, opcionalmente encerrado entre llaves. Las secuencias <code class="literal">\1</code>,
   <code class="literal">\g1</code> y <code class="literal">\g{1}</code> son sinónimas
   entre sí. El uso de este patrón con un número sin signo puede ayudar a eliminar la ambigüedad inherente al usar dígitos después de una barra invertida. La secuencia ayuda a distinguir referencias inversas de caracteres octales y también facilita tener una referencia inversa seguida de un número literal, por ejemplo <code class="literal">\g{2}1</code>.
  </p>
  <p class="para">
   El uso de la secuencia <code class="literal">\g</code> con un número negativo
   significa una referencia relativa. Por ejemplo, <code class="literal">(foo)(bar)\g{-1}</code>
   coincidiría con la secuencia "foobarbar" y <code class="literal">(foo)(bar)\g{-2}</code>
   coincide con "foobarfoo". Esto puede ser útil en patrones largos como una alternativa a llevar la cuenta del número de subpatrones para referirse
   a un subpatrón específico anterior.
  </p>
  <p class="para">
   Las referencias inversas a los subpatrones con nombre pueden lograrse mediante
   <code class="literal">(?P=name)</code>,
   <code class="literal">\k&lt;name&gt;</code>, <code class="literal">\k'name'</code>,
   <code class="literal">\k{name}</code>, <code class="literal">\g{name}</code>,
   <code class="literal">\g&lt;name&gt;</code> o <code class="literal">\g'name'</code>.
  </p>
 </div>
<hr>


 <div id="regexp.reference.assertions" class="section"><hr>
  <h2 class="title">Afirmaciones</h2>
  <p class="para">
   Una afirmación es una prueba sobre los caracteres que siguen o preceden al punto de coincidencia actual que no consume realmente ningún carácter. Las afirmaciones simples codificadas como \b,
   \B, \A, \Z, \z, ^ y $ se describen en <a href="#regexp.reference.escape" class="link">secuencias de escape</a>. Las afirmaciones más complicadas se codifican como subpatrones. Hay dos
   tipos: aquellos que <em>miran hacia adelante</em> de la posición actual en la
   cadena de sujeto, y aquellos que <em>miran hacia atrás</em> de ella.
  </p>
  <p class="para">
   Un subpatrón de afirmación se coincide de la manera normal, excepto
   que no hace que la posición de coincidencia actual cambie. <em>Afirmaciones de anticipación</em> comienzan con (?= para afirmaciones positivas y (?! para afirmaciones negativas. Por ejemplo,

   <code class="literal">\w+(?=;)</code>

   coincide con una palabra seguida de un punto y coma, pero no incluye
   el punto y coma en la coincidencia, y

   <code class="literal">foo(?!bar)</code>

   coincide con cualquier ocurrencia de "foo" que no esté seguida por
   "bar". Tenga en cuenta que el patrón aparentemente similar

   <code class="literal">(?!foo)bar</code>

   no encuentra una ocurrencia de "bar" que esté precedida por algo que no sea "foo"; encuentra cualquier ocurrencia de "bar"
   en absoluto, porque la afirmación (?!foo) es siempre <strong><code><a href="#constant.true">true</a></code></strong>
   cuando los siguientes tres caracteres son "bar". Se necesita una afirmación de retroceso para lograr este efecto.
  </p>
  <p class="para">
   <em>Afirmaciones de retroceso</em> comienzan con (?&lt;= para afirmaciones positivas y (?&lt;! para afirmaciones negativas. Por ejemplo,

   <code class="literal">(?&lt;!foo)bar</code>

   sí encuentra una ocurrencia de "bar" que no está precedida por
   "foo". El contenido de una afirmación de retroceso está restringido
   de tal manera que todas las cadenas que coincide deben tener una longitud fija. Sin embargo, si hay varias alternativas, no todas tienen que tener la misma longitud fija. Por lo tanto

   <code class="literal">(?&lt;=bullock|donkey)</code>

   está permitido, pero

   <code class="literal">(?&lt;!dogs?|cats?)</code>

   causa un error en el momento de la compilación. Las ramas que coinciden con cadenas de diferentes longitudes están permitidas solo al nivel superior
   de una afirmación de retroceso. Esto es una extensión en comparación con Perl 5.005, que requiere que todas las ramas coincidan con la misma longitud de cadena. Una afirmación como

   <code class="literal">(?&lt;=ab(c|de))</code>

   no está permitida, porque su única rama de nivel superior puede coincidir con dos longitudes diferentes, pero es aceptable si se reescribe para usar dos ramas de nivel superior:

   <code class="literal">(?&lt;=abc|abde)</code>

   La implementación de afirmaciones de retroceso es, para cada alternativa, mover temporalmente la posición actual hacia atrás por el ancho fijo y luego intentar coincidir. Si no hay suficientes caracteres antes de la posición actual, la coincidencia se considera fallida. Los retrocesos en conjunto con subpatrones de una sola vez pueden ser particularmente útiles para coincidir al final de las cadenas; se da un ejemplo al final
   de la sección sobre subpatrones de una sola vez.
  </p>
  <p class="para">
   Varias afirmaciones (de cualquier tipo) pueden ocurrir en sucesión.
   Por ejemplo,

   <code class="literal">(?&lt;=\d{3})(?&lt;!999)foo</code>

   coincide con "foo" precedido por tres dígitos que no son "999".
   Observe que cada una de las afirmaciones se aplica independientemente
   en el mismo punto de la cadena de sujeto. Primero hay una verificación de que los tres caracteres anteriores son todos dígitos,
   luego hay una verificación de que los mismos tres caracteres no son "999". Este patrón no coincide con "foo" precedido por seis
   caracteres, el primero de los cuales son dígitos y los últimos tres de los cuales no son "999". Por ejemplo, no coincide
   con "123abcfoo". Un patrón para hacer eso es

   <code class="literal">(?&lt;=\d{3}...)(?&lt;!999)foo</code>
  </p>
  <p class="para">
   Esta vez la primera afirmación mira los seis caracteres anteriores, verificando que los primeros tres son dígitos, y
   luego la segunda afirmación verifica que los tres caracteres anteriores no son "999".
  </p>
  <p class="para">
   Las afirmaciones pueden anidarse en cualquier combinación. Por ejemplo,

   <code class="literal">(?&lt;=(?&lt;!foo)bar)baz</code>

   coincide con una ocurrencia de "baz" que es precedida por "bar"
   que a su vez no es precedida por "foo", mientras que

   <code class="literal">(?&lt;=\d{3}...(?&lt;!999))foo</code>

   es otro patrón que coincide con "foo" precedido por tres
   dígitos y cualquier tres caracteres que no son "999".
  </p>
  <p class="para">
   Los subpatrones de afirmación no son subpatrones de captura, y no pueden
   repetirse, porque no tiene sentido afirmar lo mismo varias veces. Si cualquier tipo de afirmación contiene subpatrones de captura dentro de ella, estos se cuentan para los fines de numerar los subpatrones de captura en todo
   el patrón. Sin embargo, la captura de subcadenas solo se lleva a cabo para afirmaciones positivas, porque no tiene sentido para afirmaciones negativas.
  </p>
  <p class="para">
   Las afirmaciones cuentan hacia el máximo de 200 subpatrones entre paréntesis.
  </p>
 </div>
<hr>


 <div id="regexp.reference.onlyonce" class="section"><hr>
  <h2 class="title">Subpatrones de una sola vez</h2>
  <p class="para">
   Con la repetición de maximización y minimización, el fracaso de lo que sigue normalmente hace que el elemento repetido se reevalúe para ver si un número diferente de repeticiones permite que el resto del patrón coincida. A veces es útil
   evitar esto, ya sea para cambiar la naturaleza de la coincidencia, o
   para hacer que falle antes de lo que lo haría de otra manera, cuando el autor del patrón sabe que no hay punto en continuar.
  </p>
  <p class="para">
   Considere, por ejemplo, el patrón \d+foo cuando se aplica a
   la línea de sujeto

   <code class="literal">123456bar</code>
  </p>
  <p class="para">
   Después de coincidir con todos los 6 dígitos y luego fallar al coincidir con "foo",
   la acción normal del coincidente es intentar nuevamente con solo 5
   dígitos coincidiendo con el elemento \d+, y luego con 4, y así sucesivamente,
   antes de fallar finalmente. Los subpatrones de una sola vez proporcionan el medio para especificar que una vez que una parte del patrón ha coincidido, no debe ser revaluada de esta manera, por lo que el coincidente se rendiría inmediatamente al fallar en coincidir con "foo"
   la primera vez. La notación es otro tipo de paréntesis especial, comenzando con (?&gt; como en este ejemplo:

   <code class="literal">(?&gt;\d+)bar</code>
  </p>
  <p class="para">
   Este tipo de paréntesis "bloquea" la parte del patrón que contiene una vez que ha coincidido, y un fallo más adelante en el patrón se impide retroceder hacia él.
   Retroceder más allá de él, sin embargo, funciona como de costumbre.
  </p>
  <p class="para">
   Una descripción alternativa es que un subpatrón de este tipo
   coincide con la cadena de caracteres que un patrón independiente idéntico coincidiría, si se anclara en el punto
   actual en la cadena de sujeto.
  </p>
  <p class="para">
   Los subpatrones de una sola vez no son subpatrones de captura. Casos simples como el ejemplo anterior pueden pensarse como un repetidor maximizador que debe tragarse todo lo que pueda. Por lo tanto,
   mientras que tanto \d+ como \d+? están dispuestos a ajustar el número de dígitos que coinciden para hacer que el resto del patrón coincida, (?&gt;\d+) solo puede coincidir con una secuencia completa de dígitos.
  </p>
  <p class="para">
   Esta construcción puede contener, por supuesto, subpatrones arbitrariamente complejos, y puede anidarse.
  </p>
  <p class="para">
   Los subpatrones de una sola vez pueden usarse en conjunto con afirmaciones de retroceso para especificar coincidencias eficientes al final de la cadena de sujeto. Considere un patrón simple como

   <code class="literal">abcd$</code>

   cuando se aplica a una cadena larga que no coincide. Dado que la coincidencia procede de izquierda a derecha, PCRE buscará cada "a" en el sujeto y luego verá si lo que sigue coincide con el resto del patrón. Si el patrón se especifica como

   <code class="literal">^.*abcd$</code>

   entonces el .* inicial coincide con toda la cadena al principio, pero
   cuando esto falla (porque no hay un "a" siguiente), retrocede para coincidir con todo excepto el último carácter, luego todo excepto los dos últimos caracteres, y así sucesivamente. Una vez más, la búsqueda de "a" cubre toda la cadena, de derecha a izquierda, por lo que no estamos mejor. Sin embargo, si el patrón se escribe como

   <code class="literal">^(?&gt;.*)(?&lt;=abcd)</code>

   entonces no puede haber retroceso para el elemento .*; solo puede coincidir con toda la cadena. La afirmación de retroceso posterior realiza una sola prueba en los últimos cuatro caracteres. Si falla, la coincidencia falla inmediatamente. Para cadenas largas,
   este enfoque hace una diferencia significativa en el tiempo de procesamiento.
  </p>
  <p class="para">
   Cuando un patrón contiene una repetición ilimitada dentro de un subpatrón que a su vez puede repetirse un número ilimitado de veces, el uso de un subpatrón de una sola vez es la única manera de evitar que algunas coincidencias fallidas tomen un tiempo muy largo. El patrón

   <code class="literal">(\D+|&lt;\d+&gt;)*[!?]</code>

   coincide con un número ilimitado de subcadenas que consisten en no dígitos, o dígitos encerrados en &lt;&gt;, seguido de
   ! o ?. Cuando coincide, funciona rápidamente. Sin embargo, si se aplica a

   <code class="literal">aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa</code>

   tarda mucho tiempo en informar el fallo. Esto se debe a
   que la cadena puede dividirse entre las dos repeticiones de muchas maneras, y todas tienen que ser probadas antes de que se pueda informar el fallo. (El ejemplo usó [!?] en lugar de un solo carácter al final,
   porque tanto PCRE como Perl tienen una optimización que permite un fallo rápido cuando se usa un solo carácter. Recuerdan el último carácter único que se requiere para una coincidencia, y fallan temprano si no está presente en la cadena.)
   Si el patrón se cambia a

   <code class="literal">((?&gt;\D+)|&lt;\d+&gt;)*[!?]</code>

   las secuencias de no dígitos no pueden romperse, y el fallo ocurre rápidamente.
  </p>
 </div>
<hr>


 <div id="regexp.reference.conditional" class="section"><hr>
  <h2 class="title">Subpatrones condicionales</h2>
  <p class="para">
   Es posible hacer que el proceso de coincidencia obedezca un subpatrón
   condicionalmente o elegir entre dos subpatrones alternativos,
   dependiendo del resultado de una afirmación, o
   si un subpatrón de captura anterior coincidió o no. Las
   dos formas posibles de subpatrón condicional son
  </p>

  <div class="informalexample">
   <div class="example-contents">
<div class="annotation-interactive cdata"><pre>
(?(condition)yes-pattern)
(?(condition)yes-pattern|no-pattern)
</pre></div>
   </div>

  </div>
  <p class="para">
   Si la condición se cumple, se usa el yes-pattern; de lo contrario
   se usa el no-pattern (si está presente). Si hay
   más de dos alternativas en el subpatrón, ocurre un error en el momento de la compilación.
  </p>
  <p class="para">
   Hay dos tipos de condiciones. Si el texto entre los
   paréntesis consiste en una secuencia de dígitos, entonces la
   condición se cumple si el subpatrón de captura de ese número ha coincidido anteriormente. Considere el siguiente patrón,
   que contiene espacio en blanco no significativo para hacerlo
   más legible (asumiendo la <a href="#reference.pcre.pattern.modifiers" class="link">opción PCRE_EXTENDED</a>
   y para dividirlo en tres partes para facilitar la discusión):
  </p>
  <div class="informalexample">
   <div class="example-contents">
<div class="annotation-interactive cdata"><pre>
( \( )? [^()]+ (?(1) \) )
</pre></div>
   </div>

  </div>
  <p class="para">
   La primera parte coincide con un paréntesis de apertura opcional, y
   si ese carácter está presente, lo establece como la primera subcadena capturada. La segunda parte coincide con uno o más caracteres que no son paréntesis. La tercera parte es un subpatrón condicional que prueba si el primer conjunto de paréntesis
   coincidió o no. Si lo hicieron, es decir, si el sujeto comenzó con un paréntesis de apertura, la condición es <strong><code><a href="#constant.true">true</a></code></strong>, y por lo tanto el yes-pattern se ejecuta y se requiere un paréntesis de cierre. De lo contrario, ya que no-pattern no está presente, el subpatrón coincide con nada. En otras palabras, este patrón coincide con una secuencia de caracteres no paréntesis, opcionalmente encerrada en paréntesis.
  </p>
  <p class="para">
   Si la condición es la cadena <code class="literal">(R)</code>, se cumple si se ha realizado una llamada recursiva al patrón o subpatrón. En "nivel superior", la condición es falsa.
  </p>
  <p class="para">
   Si la condición no es una secuencia de dígitos o (R), debe ser una
   afirmación. Esta puede ser una afirmación positiva o negativa de anticipación o retroceso. Considere este patrón, que nuevamente contiene espacio en blanco no significativo, y con las dos alternativas en la segunda línea:
  </p>

  <div class="informalexample">
   <div class="example-contents">
<div class="annotation-interactive cdata"><pre>
(?(?=[^a-z]*[a-z])
\d{2}-[a-z]{3}-\d{2} | \d{2}-\d{2}-\d{2} )
</pre></div>
   </div>

  </div>
  <p class="para">
   La condición es una afirmación positiva de anticipación que coincide con una secuencia opcional de caracteres no letras seguida de una letra. En otras palabras, prueba la presencia de al menos una
   letra en el sujeto. Si se encuentra una letra, el sujeto se compara con la primera alternativa; de lo contrario, se compara con la segunda. Este patrón coincide con cadenas en una de las dos formas dd-aaa-dd o dd-dd-dd, donde aaa son letras y dd son dígitos.
  </p>
 </div>
<hr>


 <div id="regexp.reference.comments" class="section"><hr>
  <h2 class="title">Comentarios</h2>
  <p class="para">
   La secuencia (?# marca el inicio de un comentario que
   continúa hasta el siguiente paréntesis de cierre. No se permiten paréntesis anidados. Los caracteres que componen un
   comentario no participan en absoluto en la coincidencia del patrón.
  </p>
  <p class="para">
   Si la <a href="#reference.pcre.pattern.modifiers" class="link">opción PCRE_EXTENDED</a> está establecida, un carácter # no escapado fuera de una clase de caracteres
   introduce un comentario que continúa hasta el siguiente carácter de nueva línea en el patrón.
  </p>
  <p class="para">
   </p><div class="example" id="example-5034">
    <p><strong>Ejemplo #1 Uso de comentarios en el patrón PCRE</strong></p>
    <div class="example-contents">
<div class="annotation-interactive phpcode"><code><span style="color: #000000"><span style="color: #0000BB">&lt;?php<br><br>$subject </span><span style="color: #007700">= </span><span style="color: #DD0000">'test'</span><span style="color: #007700">;<br><br></span><span style="color: #FF8000">/* (?# puede usarse para agregar comentarios sin habilitar PCRE_EXTENDED */<br></span><span style="color: #0000BB">$match </span><span style="color: #007700">= </span><span style="color: #0000BB">preg_match</span><span style="color: #007700">(</span><span style="color: #DD0000">'/te(?# este es un comentario)st/'</span><span style="color: #007700">, </span><span style="color: #0000BB">$subject</span><span style="color: #007700">);<br></span><span style="color: #0000BB">var_dump</span><span style="color: #007700">(</span><span style="color: #0000BB">$match</span><span style="color: #007700">);<br><br></span><span style="color: #FF8000">/* El espacio en blanco y # se trata como parte del patrón a menos que PCRE_EXTENDED esté habilitado */<br></span><span style="color: #0000BB">$match </span><span style="color: #007700">= </span><span style="color: #0000BB">preg_match</span><span style="color: #007700">(</span><span style="color: #DD0000">'/te   #~~~~<br>st/'</span><span style="color: #007700">, </span><span style="color: #0000BB">$subject</span><span style="color: #007700">);<br></span><span style="color: #0000BB">var_dump</span><span style="color: #007700">(</span><span style="color: #0000BB">$match</span><span style="color: #007700">);<br><br></span><span style="color: #FF8000">/* Cuando PCRE_EXTENDED está habilitado, todos los caracteres de espacio en blanco y cualquier cosa<br>   que siga a un # no escapado en la misma línea se ignoran */<br></span><span style="color: #0000BB">$match </span><span style="color: #007700">= </span><span style="color: #0000BB">preg_match</span><span style="color: #007700">(</span><span style="color: #DD0000">'/te    #~~~~<br>st/x'</span><span style="color: #007700">, </span><span style="color: #0000BB">$subject</span><span style="color: #007700">);<br></span><span style="color: #0000BB">var_dump</span><span style="color: #007700">(</span><span style="color: #0000BB">$match</span><span style="color: #007700">);</span></span></code></div>
    </div>

    <div class="example-contents"><p>El ejemplo anterior mostrará:</p></div>
    <div class="example-contents screen">
<div class="annotation-interactive cdata"><pre>
int(1)
int(0)
int(1)
</pre></div>
    </div>
   </div>
  
 </div>
<hr>


 <div id="regexp.reference.recursive" class="section"><hr>
  <h2 class="title">Patrones recursivos</h2>
  <p class="para">
   Considere el problema de hacer coincidir una cadena entre paréntesis,
   permitiendo paréntesis anidados ilimitados. Sin el uso
   de recursión, lo mejor que se puede hacer es usar un patrón
   que coincide hasta una profundidad fija de anidamiento. No
   es posible manejar una profundidad de anidamiento arbitraria. Perl 5.6 ha
   proporcionado una instalación experimental que permite que las expresiones regulares sean recursivas (entre otras cosas). Se proporciona el elemento especial (?R) para el caso específico de recursión.
   Este patrón PCRE resuelve el problema de los paréntesis (asumiendo
   que la <a href="#reference.pcre.pattern.modifiers" class="link">opción PCRE_EXTENDED</a> está establecida para que el espacio en blanco se
   ignore):

   <code class="literal">\( ( (?&gt;[^()]+) | (?R) )* \)</code>
  </p>
  <p class="para">
   Primero coincide con un paréntesis de apertura. Luego coincide con cualquier
   número de subcadenas que pueden ser una secuencia de caracteres no paréntesis, o una coincidencia recursiva del patrón mismo (es decir, una subcadena correctamente entre paréntesis). Finalmente hay un paréntesis de cierre.
  </p>
  <p class="para">
   Este ejemplo de patrón en particular contiene repeticiones ilimitadas anidadas, y por lo tanto el uso de un subpatrón de una sola vez para coincidir con cadenas de caracteres no paréntesis es importante al aplicar
   el patrón a cadenas que no coinciden. Por ejemplo, cuando se aplica a

   <code class="literal">(aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa()</code>

   produce "no coincide" rápidamente. Sin embargo, si no se usa un subpatrón de una sola vez, la coincidencia tarda un tiempo muy largo
   porque hay tantas formas diferentes en que las repeticiones + y * pueden dividir el sujeto, y todas tienen que ser probadas antes de que se pueda informar el fallo.
  </p>
  <p class="para">
   Los valores establecidos para cualquier subpatrón de captura son aquellos del nivel más externo de la recursión en el que se establece el valor del subpatrón. Si el patrón anterior coincide con

   <code class="literal">(ab(cd)ef)</code>

   el valor para los paréntesis de captura es "ef", que es el último valor tomado en el nivel superior. Si se añaden más paréntesis, dando

   <code class="literal">\( ( ( (?&gt;[^()]+) | (?R) )* ) \)</code>
   entonces la cadena que capturan
   es "ab(cd)ef", el contenido de los paréntesis de nivel superior. Si hay más de 15 paréntesis de captura en un patrón,
   PCRE tiene que obtener memoria adicional para almacenar datos durante una
   recursión, lo cual hace mediante el uso de pcre_malloc, liberándola posteriormente mediante pcre_free. Si no se puede obtener memoria, solo guarda datos para los primeros 15 subpatrones de captura, ya que no hay forma de dar un error de memoria insuficiente desde dentro de una recursión.
  </p>

  <p class="para">
   <code class="literal">(?1)</code>, <code class="literal">(?2)</code> y así sucesivamente pueden usarse para subpatrones recursivos también. También es posible usar subpatrones con nombre: <code class="literal">(?P&gt;name)</code> o
   <code class="literal">(?&amp;name)</code>.
  </p>
  <p class="para">
   Si la sintaxis para una referencia de subpatrón recursivo (ya sea por número o por nombre) se usa fuera de los paréntesis a los que se refiere, opera como una subrutina en un lenguaje de programación. Un ejemplo anterior señaló que el patrón
   <code class="literal">(sens|respons)e and \1ibility</code>
   coincide con "sense and sensibility" y "response and responsibility", pero
   no con "sense and responsibility". Si en su lugar se usa el patrón
   <code class="literal">(sens|respons)e and (?1)ibility</code>
   sí coincide con "sense and responsibility" además de las otras dos cadenas. Tales referencias deben, sin embargo, seguir al subpatrón al que se refieren.
  </p>

  <p class="para">
   La longitud máxima de una cadena de sujeto es el número positivo más grande
   que puede contener una variable entera. Sin embargo, PCRE usa recursión para
   manejar subpatrones y repetición indefinida. Esto significa que el espacio de pila disponible puede limitar el tamaño de una cadena de sujeto que puede ser
   procesada por ciertos patrones.
  </p>

 </div>
<hr>


 <div id="regexp.reference.performance" class="section"><hr>
  <h2 class="title">Rendimiento</h2>
  <p class="para">
   Ciertos elementos que pueden aparecer en patrones son más eficientes
   que otros. Es más eficiente usar una clase de caracteres como [aeiou] que un conjunto de alternativas como (a|e|i|o|u).
   En general, la construcción más simple que proporciona el
   comportamiento requerido suele ser la más eficiente. El libro de Jeffrey
   Friedl contiene mucha discusión sobre cómo optimizar expresiones regulares para un rendimiento eficiente.
  </p>
  <p class="para">
   Cuando un patrón comienza con .* y la <a href="#reference.pcre.pattern.modifiers" class="link">opción PCRE_DOTALL</a> está
   establecida, el patrón está implícitamente anclado por PCRE, ya que
   solo puede coincidir al inicio de una cadena de sujeto. Sin embargo, si
   <a href="#reference.pcre.pattern.modifiers" class="link">PCRE_DOTALL</a> no está establecida, PCRE no puede hacer esta optimización,
   porque el metacarácter . no coincide entonces con un salto de línea,
   y si la cadena de sujeto contiene saltos de línea, el patrón puede
   coincidir desde el carácter inmediatamente después de uno de ellos
   en lugar de desde el principio. Por ejemplo, el patrón

   <code class="literal">(.*) second</code>

   coincide con la cadena de sujeto "first\nand second" (donde \n representa
   un carácter de nueva línea) con la primera subcadena capturada siendo
   "and". Para hacer esto, PCRE tiene que volver a intentar la coincidencia
   comenzando después de cada salto de línea en el sujeto.
  </p>
  <p class="para">
   Si está utilizando un patrón como este con cadenas de sujeto que no contienen saltos de línea, el mejor rendimiento se obtiene estableciendo <a href="#reference.pcre.pattern.modifiers" class="link">PCRE_DOTALL</a>,
   o comenzando el patrón con ^.* para
   indicar anclaje explícito. Esto ahorra a PCRE tener que escanear a lo largo del sujeto buscando un salto de línea para reiniciar.
  </p>
  <p class="para">
   Tenga cuidado con los patrones que contienen repeticiones indefinidas anidadas.
   Estos pueden tardar mucho tiempo en ejecutarse cuando se aplican a una cadena
   que no coincide. Considere el fragmento de patrón

   <code class="literal">(a+)*</code>
  </p>
  <p class="para">
   Esto puede coincidir con "aaaa" de 33 maneras diferentes, y este número
   aumenta muy rápidamente a medida que la cadena se alarga. (La repetición *
   puede coincidir 0, 1, 2, 3 o 4 veces, y para cada uno de
   esos casos excepto 0, las repeticiones + pueden coincidir con diferentes
   números de veces.) Cuando el resto del patrón es tal que
   toda la coincidencia va a fallar, PCRE en principio
   tiene que probar cada variación posible, y esto puede tomar un
   tiempo extremadamente largo.
  </p>
  <p class="para">
   Una optimización atrapa algunos de los casos más simples como
   <code class="literal">(a+)*b</code>
   donde un carácter literal sigue. Antes de embarcarse en el
   procedimiento de coincidencia estándar, PCRE verifica que hay una "b"
   más adelante en el sujeto, y si no la hay, falla la coincidencia inmediatamente. Sin embargo, cuando no hay un carácter literal siguiente, esta optimización no puede usarse. Puede ver la diferencia comparando el comportamiento de

   <code class="literal">(a+)*\d</code>

   con el patrón anterior. El primero da un fallo casi
   instantáneamente cuando se aplica a una línea completa de caracteres "a",
   mientras que el segundo tarda un tiempo apreciable con cadenas
   más largas que unas 20 caracteres.
  </p>
 </div>
<hr>

</div>

<hr>




 




<div id="reference.pcre.pattern.modifiers" class="article"><hr>
 <h1 class="title">Opciones de búsqueda</h1>

 
  <p class="para">
   Las opciones de PCRE se listan a continuación. Los nombres entre
   paréntesis son los nombres internos a PCRE.
   Los espacios y los caracteres de nueva línea son ignorados
   en los modificadores, los otros caracteres causan errores.
  </p>
  <p class="para">
   </p><blockquote class="blockquote">
    <dl>
     
      <dt><em>i</em> (<code class="literal">PCRE_CASELESS</code>)</dt>
      <dd>
       <span class="simpara">
        Realiza una búsqueda insensible a la casilla.
       </span>
      </dd>
     
     
      <dt><em>m</em> (<code class="literal">PCRE_MULTILINE</code>)</dt>
      <dd>
       <span class="simpara">
        Por omisión, PCRE trata la cadena sujeto como una sola
        línea (aunque esta cadena contenga retornos de carro).
        El metacarácter "inicio de línea" (^) solo será
        válido una vez, al inicio de la línea, y el
        metacarácter "fin de línea" ($) solo será válido
        al final de la cadena, o antes del retorno de carro
        final (a menos que se active la opción <em>D</em>).
        Es el mismo funcionamiento que en Perl.
       </span>
       <span class="simpara">
        Cuando esta opción está activada, "inicio de línea" y
        "fin de línea" corresponderán entonces a los caracteres
        siguiente y precedente inmediatamente a
        un carácter de nueva línea, además del inicio
        y del final de la cadena. Es el mismo
        funcionamiento que la opción Perl /m. Si no hay ningún
        carácter de nueva línea "\n" en la cadena sujeto,
        o si no hay ninguna ocurrencia de ^ o $ en el patrón, esta opción
        no sirve de nada.
       </span>
      </dd>
     
     
      <dt><em>s</em> (<code class="literal">PCRE_DOTALL</code>)</dt>
      <dd>
       <span class="simpara">
        Con esta opción, el metacarácter punto (.)
        reemplaza cualquier carácter, incluyendo las nuevas
        líneas. Sin esta opción, el carácter punto no reemplaza
        las nuevas líneas. Esta opción es equivalente
        a la opción Perl /s. Una clase de caracteres
        negativa como [^a] aceptará siempre los
        caracteres de nuevas líneas, independientemente
        de esta opción.
       </span>
      </dd>
     
     
      <dt><em>x</em> (<code class="literal">PCRE_EXTENDED</code>)</dt>
      <dd>
       <span class="simpara">
        Con esta opción, los caracteres de espacio son
        ignorados, excepto cuando están escapados,
        o dentro de una clase de caracteres,
        y todos los caracteres entre # no escapados
        y fuera de una clase de caracteres, y el próximo
        carácter de nueva línea son ignorados. Es
        el equivalente Perl de la opción /x: permite añadir
        comentarios en los patrones complicados. Tenga en cuenta,
        sin embargo, que esto solo se aplica a los caracteres de
        datos. Los caracteres de espacio nunca deben
        aparecer en las secuencias especiales
        de un patrón, por ejemplo en la secuencia (?( que
        introduce un paréntesis condicional.
       </span>
      </dd>
     
     
      <dt><em>A</em> (<code class="literal">PCRE_ANCHORED</code>)</dt>
      <dd>
       <span class="simpara">
        Con esta opción, el patrón está anclado de forma forzada, es decir
        que el patrón debe aplicarse justo al inicio de la cadena sujeto
        para ser considerado encontrado. Es posible realizar el
        mismo efecto añadiendo los metacaracteres adecuados, lo cual es la
        única manera de hacerlo en Perl.
       </span>
      </dd>
     
     
      <dt><em>D</em> (<code class="literal">PCRE_DOLLAR_ENDONLY</code>)</dt>
      <dd>
       <span class="simpara">
        Con esta opción, el metacarácter $ solo será
        válido al final de la cadena sujeto. Sin
        esta opción, $ también es válido antes de una nueva línea,
        si esta última es el último carácter de
        la cadena. Esta opción es ignorada si la opción
        <em>m</em> está activada. No hay
        equivalente en Perl.
       </span>
      </dd>
     
     
      <dt><em>S</em></dt>
      <dd>
       <span class="simpara">
        Cuando un patrón se utiliza varias veces, vale la pena
        pasar unos instantes más para analizarlo
        y optimizar el código para acelerar los
        tratamientos posteriores. Esta opción fuerza este
        análisis más exhaustivo. Actualmente, este análisis
        solo es útil para los patrones no anclados, que
        no comienzan por un carácter fijo.
        Desde PHP 7.3.0, esta bandera ya no tiene efecto.
       </span>
      </dd>
     
     
      <dt><em>U</em> (<code class="literal">PCRE_UNGREEDY</code>)</dt>
      <dd>
       <span class="simpara">
        Esta opción invierte la tendencia a la gula de las
        expresiones regulares. También puede invertirse
        esta tendencia caso por caso con un <code class="literal">?</code> pero
        esto hará gula la secuencia. Esta opción no es compatible
        con Perl. También puede ponerse en el patrón con
        la opción <code class="literal">(?U)</code> en el
        <a href="#regexp.reference.internal-options" class="link">patrón</a> o
        por un punto de interrogación antes del cuantificador (.e.g. <code class="literal">.*?</code>).
       </span>
       <blockquote class="note"><p><strong class="note">Nota</strong>: 
        </p><p class="para">
         No es generalmente posible hacer coincidir
         más que el límite de <a href="#ini.pcre.backtrack-limit" class="link">pcre.backtrack_limit</a>
         caracteres en modo no gula.
        </p>
       </blockquote>
      </dd>
     
     
      <dt><em>X</em> (<code class="literal">PCRE_EXTRA</code>)</dt>
      <dd>
       <span class="simpara">
        Esta opción añade otras funcionalidades incompatibles
        con el PCRE de Perl. Todos los antislashs seguidos de una letra que
        no tendría un significado particular causan un error,
        permitiendo la reserva de estas combinaciones para futuras
        funcionalidades. Por omisión, como en Perl, los
        antislashs seguidos de una letra sin significado particular
        son tratados como valores literales. Actualmente,
        esta opción no activa otras funciones.
       </span>
      </dd>
     
     
      <dt><em>J</em> (<code class="literal">PCRE_INFO_JCHANGED</code>)</dt>
      <dd>
       <span class="simpara">
        La opción interna de configuración (?J) modifica la opción local <code class="literal">PCRE_DUPNAMES</code>.
        Permite la duplicación de nombres para los subpatrones.
        A partir de PHP 7.2.0 <code class="literal">J</code> también es soportado como modificador.
       </span>
      </dd>
     
     
      <dt><em>u</em> (<code class="literal">PCRE_UTF8</code>)</dt>
      <dd>
       <span class="simpara">
        Esta opción activa funcionalidades adicionales de PCRE que no son compatibles con Perl.
        La cadena de entrada y el patrón son tratados como cadenas UTF-8.
        Una cadena de entrada inválida tendrá como consecuencia una ausencia de coincidencia en las funciones preg_*.
        Un patrón inválido levantará un error de nivel <strong><code><a href="#constant.e-warning">E_WARNING</a></code></strong>.
        Las secuencias UTF-8 de cinco y seis octetos son consideradas inválidas.
       </span>
      </dd>
     
     
      <dt><em>n</em> (<code class="literal">PCRE_NO_AUTO_CAPTURE</code>)</dt>
      <dd>
       <span class="simpara">
        Este modificador hace que los grupos simples <code class="code">(xyz)</code> no sean capturantes.
        Solo los grupos nombrados como <code class="code">(?&lt;name&gt;xyz)</code> son capturantes.
        Esto afecta únicamente a los grupos capturantes, siempre es posible
        utilizar referencias de subpatrón numeradas, y el array de
        coincidencias contendrá siempre resultados numerados.
        Disponible a partir de PHP 8.2.0
       </span>
      </dd>
     
     
      <dt><em>r</em> (<code class="literal">PCRE2_EXTRA_CASELESS_RESTRICT</code>)</dt>
      <dd>
       <span class="simpara">
        Cuando <em>u</em> (<code class="literal">PCRE_UTF8</code>) y <em>i</em> (<code class="literal">PCRE_CASELESS</code>)
        están activos, este modificador impide la coincidencia entre los caracteres ASCII y no-ASCII.
       </span>
       <span class="simpara">
        Por ejemplo, <code class="code">preg_match('/\x{212A}/iu', "K")</code> coincide con el símbolo Kelvin <code class="literal">K</code> (U+212A).
        Cuando <em>r</em> es utilizado (<code class="code">preg_match('/\x{212A}/iur', "K")</code>, esto no coincide.
       </span>
       <span class="simpara">
        Disponible a partir de PHP 8.4.0.
       </span>
      </dd>
     
    </dl>
   </blockquote>
  
</div>

<hr>




 




<div id="reference.pcre.pattern.differences" class="article"><hr>
 <h1 class="title">Diferencias con Perl</h1>

 
 <p class="para">
  Las diferencias descritas aquí se refieren a las que hay con Perl 5.005.
  </p><ol type="1">
   <li class="listitem">
    <span class="simpara">
     Por defecto, un carácter espacio en blanco es cualquier carácter que
     la función isspace() de la biblioteca C reconoce, aunque es
     posible compilar PCRE con tablas de tipo de caracteres alternativas.
     Normalmente isspace() coincide con un espacio, salto de página, nueva línea,
     retorno de carro, tabulador horizontal y tabulador vertical. Perl 5 ya
     no incluye el tabulador vertical en su juego caracteres de espacios en blanco.
     De hecho, el carácter de escape \v, el cual estuvo en la documentación de Perl
     durante mucho tiempo, nunca fue reconocido. Sin embargo, el carácter
     mismo fue tratado como espacio en blanco al menos hasta 5.002.
     En 5.004 y 5.005 no coincide con \s.
    </span>
   </li>
   <li class="listitem">
    <span class="simpara">
     PCRE no permite los cuantificadores de repetición en declaraciones
     de búsqueda hacia delante. Perl las permite, pero no significan lo que
     se puede estar pensando. Por ejemplo, (?!a){3} no afirma que los
     tres caracteres siguientes no son "a". Simplemente afirma que el
     siguiente carácter no es "a" tres veces.
    </span>
   </li>
   <li class="listitem">
    <span class="simpara">
     Los sub-patrones de captura que tienen lugar dentro de declaraciones
     de búsqueda hacia delante negativas se cuentan, pero sus entradas en los
     índices del vector nunca se establecen. Perl establece sus variables
     numéricas desde cualquiera de los patrones que han coincidido antes de que
     la declaración falle al coincidir con algo (de ese modo teniendo éxito), pero
     sólo si la declaración de búsqueda hacia delante negativa contiene sólo una rama.
    </span>
   </li>
   <li class="listitem">
    <span class="simpara">
     Aunque los caracteres cero binario están soportados en la cadena objetivo,
     no están permitidos en un patrón de cadena porque es pasado como una
     cadena C normal, finalizada por cero. La secuencia de escape "\x00" se puede
     usar para representar un cero binario en un patrón.
    </span>
    </li>
    <li class="listitem">
    <span class="simpara">
     Las siguientes secuencias de escape de Perl no estás soportadas:
     \l,  \u,  \L,  \U. De hecho, éstas están implementadas por
     el manejo de cadenas general de Perl y no son parte de su motor de
     comparación de patrones.
    </span>
    </li>
    <li class="listitem">
    <span class="simpara">
     La declaración \G de Perl no está soportada y no es
     relevante para las comparaciones de patrones individuales.
    </span>
    </li>
    <li class="listitem">
    <span class="simpara">
     Obviamente, PCRE no soporta la construcción de (?{código}) y
     (??{código}). Sin embargo, tiene soporte para patrones recursivos.
    </span>
    </li>
    <li class="listitem">
    <span class="simpara">
     Hay, a la hora de escribir, algunas singularidades en Perl
     5.005_02 concernientes con la configuración de las cadenas capturadas
     cuando una parte de un patrón se repite. Por ejemplo, al comparar
     "aba" con el patrón /^(a(b)?)+$/ establece $2 con el valor
     "b", pero al comparar "aabbaa" con /^(aa(bb)?)+$/ deja $2
     sin establecer. Sin embargo, si el patrón se cambia a
     /^(aa(b(b))?)+$/ entonces $2 (y $3) se establecen.
     En Perl 5.004 $2 es establecido en ambos casos, y esto también es <strong><code><a href="#constant.true">true</a></code></strong>
     en PCRE. Si en el futuro Perl cambia a un estado de consistencia que es
     diferente, PCRE puede cambiar para seguir su ejemplo.
    </span>
    </li>
    <li class="listitem">
    <span class="simpara">
     Una discrepancia todavía no resuelta es que en Perl
     5.005_02 el patrón /^(a)?(?(1)a|b)+$/ coincide con la cadena
     "a", mientras que en PCRE no lo hace. Sin embargo, en Perl y en
     PCRE /^(a)?a/ coincide con "a" dejando $1 sin establecer.
    </span>
    </li>
    <li class="listitem">
    <p class="para">
     PCRE proporciona algunas extensiones para las herramientas de expresiones
     regulares de Perl:
      </p><ol type="1">
       <li class="listitem">
        <span class="simpara">
         Aunque las declaraciones de búsqueda hacia atrás deben coincidir con cadenas de
         longitud fija, cada rama alternativa de una declaración de búsqueda hacia atrás
         puede coincidir con una longitud de cadena diferente. Perl 5.005 requiere que
         todas ellas tengan la misma longitud.
       </span>
      </li>
      <li class="listitem">
       <span class="simpara">
        Si se aplica <a href="#reference.pcre.pattern.modifiers" class="link">PCRE_DOLLAR_ENDONLY</a>
        y no se aplica <a href="#reference.pcre.pattern.modifiers" class="link">PCRE_MULTILINE</a>,
        el meta-carácter $ coincide sólo con el final absoluto de la cadena.
       </span>
      </li>
      <li class="listitem">
       <span class="simpara">
        Si se aplica <a href="#reference.pcre.pattern.modifiers" class="link">PCRE_EXTRA</a>,
        una barra invertida seguida de una letra sin ningún significado especial fallará.
       </span>
      </li>
      <li class="listitem">
       <span class="simpara">
        Si se aplica <a href="#reference.pcre.pattern.modifiers" class="link">PCRE_UNGREEDY</a>,
        la codicia de los cuantificadores de repetición se invierte,
        es decir, por defecto dejan de ser codiciosos, pero si son seguidos por un
        signo de interrogación lo serán.
       </span>
      </li>
     </ol>
    
   </li>
  </ol>
 
</div>

<hr>




</div>

<hr>





 


<div id="ref.pcre" class="reference"><hr>
 <h1 class="title">Funciones de PCRE</h1>

 



<div id="function.preg-filter" class="refentry"><hr>
 <div class="refnamediv">
  <h1 class="refname">preg_filter</h1>
  <p class="verinfo">(PHP 5 &gt;= 5.3.0, PHP 7, PHP 8)</p><p class="refpurpose"><span class="refname">preg_filter</span> — <span class="dc-title">Búsqueda y reemplazo con una expresión regular</span></p>

 </div>

 <div class="refsect1 description" id="refsect1-function.preg-filter-description">
  <h3 class="title">Descripción</h3>
  <div class="methodsynopsis dc-description">
   <span class="methodname"><strong>preg_filter</strong></span>(<br>    <span class="methodparam"><span class="type"><span class="type"><a href="#language.types.string" class="type string">string</a></span>|<span class="type"><a href="#language.types.array" class="type array">array</a></span></span> <code class="parameter">$pattern</code></span>,<br>    <span class="methodparam"><span class="type"><span class="type"><a href="#language.types.string" class="type string">string</a></span>|<span class="type"><a href="#language.types.array" class="type array">array</a></span></span> <code class="parameter">$replacement</code></span>,<br>    <span class="methodparam"><span class="type"><span class="type"><a href="#language.types.string" class="type string">string</a></span>|<span class="type"><a href="#language.types.array" class="type array">array</a></span></span> <code class="parameter">$subject</code></span>,<br>    <span class="methodparam"><span class="type"><a href="#language.types.integer" class="type int">int</a></span> <code class="parameter">$limit</code><span class="initializer"> = -1</span></span>,<br>    <span class="methodparam"><span class="type"><a href="#language.types.integer" class="type int">int</a></span> <code class="parameter reference">&amp;$count</code><span class="initializer"> = <strong><code><a href="#constant.null">null</a></code></strong></span></span><br>): <span class="type"><span class="type"><a href="#language.types.string" class="type string">string</a></span>|<span class="type"><a href="#language.types.array" class="type array">array</a></span>|<span class="type"><a href="#language.types.null" class="type null">null</a></span></span></div>

  <p class="para rdfs-comment">
   <span class="function"><strong>preg_filter()</strong></span> es idéntica a
   <span class="function"><a href="#function.preg-replace" class="function">preg_replace()</a></span>, pero solo devuelve
   las ocurrencias encontradas (eventualmente transformadas). Para más detalles sobre el funcionamiento
   de esta función, véase <span class="function"><a href="#function.preg-replace" class="function">preg_replace()</a></span>.
  </p>
 </div>


 <div class="refsect1 parameters" id="refsect1-function.preg-filter-parameters">
  <h3 class="title">Parámetros</h3>
  <p class="para">
   Los parámetros están descritos en la documentación de <span class="function"><a href="#function.preg-replace" class="function">preg_replace()</a></span>.
  </p>
 </div>


 <div class="refsect1 returnvalues" id="refsect1-function.preg-filter-returnvalues">
  <h3 class="title">Valores devueltos</h3>
  <p class="para">
   Devuelve un <span class="type"><a href="#language.types.array" class="type array">array</a></span> si el parámetro <code class="parameter">subject</code>
   es de tipo <span class="type"><a href="#language.types.array" class="type array">array</a></span> o una <span class="type"><a href="#language.types.string" class="type string">string</a></span> en otro caso.
  </p>
  <p class="para">
   Si ninguna ocurrencia es encontrada o si ocurre un error,
   un <span class="type"><a href="#language.types.array" class="type array">array</a></span> vacío será devuelto cuando el parámetro
   <code class="parameter">subject</code> es un <span class="type"><a href="#language.types.array" class="type array">array</a></span> o <strong><code><a href="#constant.null">null</a></code></strong> en otro caso.
  </p>
 </div>


 <div class="refsect1 errors" id="refsect1-function.preg-filter-errors">
  <h3 class="title">Errores/Excepciones</h3>
  <p class="para">
Si el patrón regex pasado no se compila a una regex válida, se emite una <strong><code><a href="#constant.e-warning">E_WARNING</a></code></strong>.
</p>
 </div>


 <div class="refsect1 examples" id="refsect1-function.preg-filter-examples">
  <h3 class="title">Ejemplos</h3>
  <p class="para">
   </p><div class="example" id="example-5035">
    <p><strong>Ejemplo #1 
     Ejemplo de comparación de <span class="function"><strong>preg_filter()</strong></span>
     con <span class="function"><a href="#function.preg-replace" class="function">preg_replace()</a></span>
    </strong></p>
    <div class="example-contents">
<div class="annotation-interactive phpcode"><code><span style="color: #000000"><span style="color: #0000BB">&lt;?php<br>$subject </span><span style="color: #007700">= array(</span><span style="color: #DD0000">'1'</span><span style="color: #007700">, </span><span style="color: #DD0000">'a'</span><span style="color: #007700">, </span><span style="color: #DD0000">'2'</span><span style="color: #007700">, </span><span style="color: #DD0000">'b'</span><span style="color: #007700">, </span><span style="color: #DD0000">'3'</span><span style="color: #007700">, </span><span style="color: #DD0000">'A'</span><span style="color: #007700">, </span><span style="color: #DD0000">'B'</span><span style="color: #007700">, </span><span style="color: #DD0000">'4'</span><span style="color: #007700">);<br></span><span style="color: #0000BB">$pattern </span><span style="color: #007700">= array(</span><span style="color: #DD0000">'/\d/'</span><span style="color: #007700">, </span><span style="color: #DD0000">'/[a-z]/'</span><span style="color: #007700">, </span><span style="color: #DD0000">'/[1a]/'</span><span style="color: #007700">);<br></span><span style="color: #0000BB">$replace </span><span style="color: #007700">= array(</span><span style="color: #DD0000">'A:$0'</span><span style="color: #007700">, </span><span style="color: #DD0000">'B:$0'</span><span style="color: #007700">, </span><span style="color: #DD0000">'C:$0'</span><span style="color: #007700">);<br><br>echo </span><span style="color: #DD0000">"preg_filter devuelve\n"</span><span style="color: #007700">;<br></span><span style="color: #0000BB">print_r</span><span style="color: #007700">(</span><span style="color: #0000BB">preg_filter</span><span style="color: #007700">(</span><span style="color: #0000BB">$pattern</span><span style="color: #007700">, </span><span style="color: #0000BB">$replace</span><span style="color: #007700">, </span><span style="color: #0000BB">$subject</span><span style="color: #007700">));<br><br>echo </span><span style="color: #DD0000">"preg_replace devuelve\n"</span><span style="color: #007700">;<br></span><span style="color: #0000BB">print_r</span><span style="color: #007700">(</span><span style="color: #0000BB">preg_replace</span><span style="color: #007700">(</span><span style="color: #0000BB">$pattern</span><span style="color: #007700">, </span><span style="color: #0000BB">$replace</span><span style="color: #007700">, </span><span style="color: #0000BB">$subject</span><span style="color: #007700">));<br></span><span style="color: #0000BB">?&gt;</span></span></code></div>
    </div>

    <div class="example-contents"><p>El ejemplo anterior mostrará:</p></div>
    <div class="example-contents screen">
<div class="annotation-interactive examplescode"><pre class="examplescode">preg_filter devuelve
Array
(
    [0] =&gt; A:C:1
    [1] =&gt; B:C:a
    [2] =&gt; A:2
    [3] =&gt; B:b
    [4] =&gt; A:3
    [7] =&gt; A:4
)
preg_replace devuelve
Array
(
    [0] =&gt; A:C:1
    [1] =&gt; B:C:a
    [2] =&gt; A:2
    [3] =&gt; B:b
    [4] =&gt; A:3
    [5] =&gt; A
    [6] =&gt; B
    [7] =&gt; A:4
)</pre>
</div>
    </div>
   </div>
  
 </div>


 <div class="refsect1 seealso" id="refsect1-function.preg-filter-seealso">
  <h3 class="title">Ver también</h3>
  <p class="para">
   </p><ul class="simplelist">
    <li>Los <a href="#pcre.pattern" class="link">Patrones PCRE</a></li>
    <li><span class="function"><a href="#function.preg-quote" class="function" rel="rdfs-seeAlso">preg_quote()</a> - Protección de caracteres especiales de expresiones regulares</span></li>
    <li><span class="function"><a href="#function.preg-replace" class="function" rel="rdfs-seeAlso">preg_replace()</a> - Buscar y reemplazar mediante expresión regular estándar</span></li>
    <li><span class="function"><a href="#function.preg-replace-callback" class="function" rel="rdfs-seeAlso">preg_replace_callback()</a> - Buscar y reemplazar mediante expresión regular estándar utilizando una función de retrollamada</span></li>
    <li><span class="function"><a href="#function.preg-grep" class="function" rel="rdfs-seeAlso">preg_grep()</a> - Devuelve un array con los resultados de la búsqueda</span></li>
    <li><span class="function"><a href="#function.preg-last-error" class="function" rel="rdfs-seeAlso">preg_last_error()</a> - Devuelve el código de error de la última expresión PCRE ejecutada</span></li>
   </ul>
  
 </div>

</div>
<hr>







<div id="function.preg-grep" class="refentry"><hr>
 <div class="refnamediv">
  <h1 class="refname">preg_grep</h1>
  <p class="verinfo">(PHP 4, PHP 5, PHP 7, PHP 8)</p><p class="refpurpose"><span class="refname">preg_grep</span> — <span class="dc-title">Devuelve un array con los resultados de la búsqueda</span></p>

 </div>

 <div class="refsect1 description" id="refsect1-function.preg-grep-description">
  <h3 class="title">Descripción</h3>
  <div class="methodsynopsis dc-description">
   <span class="methodname"><strong>preg_grep</strong></span>(<span class="methodparam"><span class="type"><a href="#language.types.string" class="type string">string</a></span> <code class="parameter">$pattern</code></span>, <span class="methodparam"><span class="type"><a href="#language.types.array" class="type array">array</a></span> <code class="parameter">$array</code></span>, <span class="methodparam"><span class="type"><a href="#language.types.integer" class="type int">int</a></span> <code class="parameter">$flags</code><span class="initializer"> = 0</span></span>): <span class="type"><span class="type"><a href="#language.types.array" class="type array">array</a></span>|<span class="type"><a href="#language.types.singleton" class="type false">false</a></span></span></div>

  <p class="para rdfs-comment">
   <span class="function"><strong>preg_grep()</strong></span> devuelve un <span class="type"><a href="#language.types.array" class="type array">array</a></span> que contiene
   los elementos de <code class="parameter">array</code>
   que satisfacen el patrón <code class="parameter">pattern</code>.
  </p>
 </div>


 <div class="refsect1 parameters" id="refsect1-function.preg-grep-parameters">
  <h3 class="title">Parámetros</h3>
  <p class="para">
   </p><dl>
    
     <dt><code class="parameter">pattern</code></dt>
     <dd>
      <p class="para">
       El patrón a buscar, en forma de <span class="type"><a href="#language.types.string" class="type string">string</a></span>.
      </p>
     </dd>
    
    
     <dt><code class="parameter">array</code></dt>
     <dd>
      <p class="para">
       El array de entrada.
      </p>
     </dd>
    
    
     <dt><code class="parameter">flags</code></dt>
     <dd>
      <p class="para">
       Si esta opción tiene el valor <strong><code><a href="#constant.preg-grep-invert">PREG_GREP_INVERT</a></code></strong>,
       esta función devuelve los elementos del array
       <code class="parameter">input</code> que <em>no</em> coinciden
       con el patrón
       <code class="parameter">pattern</code>.
      </p>
     </dd>
    
   </dl>
  
 </div>


 <div class="refsect1 returnvalues" id="refsect1-function.preg-grep-returnvalues">
  <h3 class="title">Valores devueltos</h3>
  <p class="para">
   Devuelve un <span class="type"><a href="#language.types.array" class="type array">array</a></span> indexado, utilizando las claves del
   array <code class="parameter">array</code> de entrada,  o <strong><code><a href="#constant.false">false</a></code></strong> si ocurre un error.
  </p>
 </div>


 <div class="refsect1 errors" id="refsect1-function.preg-grep-errors">
  <h3 class="title">Errores/Excepciones</h3>
  <p class="para">
Si el patrón regex pasado no se compila a una regex válida, se emite una <strong><code><a href="#constant.e-warning">E_WARNING</a></code></strong>.
</p>
 </div>


 <div class="refsect1 examples" id="refsect1-function.preg-grep-examples">
  <h3 class="title">Ejemplos</h3>
  <p class="para">
   </p><div class="example" id="example-5036">
    <p><strong>Ejemplo #1 Ejemplo con <span class="function"><strong>preg_grep()</strong></span></strong></p>
    <div class="example-contents">
<div class="annotation-interactive phpcode"><code><span style="color: #000000"><span style="color: #0000BB">&lt;?php<br>$array </span><span style="color: #007700">= [ </span><span style="color: #DD0000">"4"</span><span style="color: #007700">, </span><span style="color: #0000BB">M_PI</span><span style="color: #007700">, </span><span style="color: #DD0000">"2.74"</span><span style="color: #007700">, </span><span style="color: #0000BB">42 </span><span style="color: #007700">];<br><br></span><span style="color: #FF8000">// devuelve todos los elementos del array que contienen números de punto flotante<br></span><span style="color: #0000BB">$fl_array </span><span style="color: #007700">= </span><span style="color: #0000BB">preg_grep</span><span style="color: #007700">(</span><span style="color: #DD0000">"/^(\d+)?\.\d+$/"</span><span style="color: #007700">, </span><span style="color: #0000BB">$array</span><span style="color: #007700">);<br><br></span><span style="color: #0000BB">var_dump</span><span style="color: #007700">(</span><span style="color: #0000BB">$fl_array</span><span style="color: #007700">);<br></span><span style="color: #0000BB">?&gt;</span></span></code></div>
    </div>

   </div>
  
 </div>


 <div class="refsect1 seealso" id="refsect1-function.preg-grep-seealso">
  <h3 class="title">Ver también</h3>
  <p class="para">
   </p><ul class="simplelist">
    <li>Los <a href="#pcre.pattern" class="link">Patrones PCRE</a></li>
    <li><span class="function"><a href="#function.preg-quote" class="function" rel="rdfs-seeAlso">preg_quote()</a> - Protección de caracteres especiales de expresiones regulares</span></li>
    <li><span class="function"><a href="#function.preg-match-all" class="function" rel="rdfs-seeAlso">preg_match_all()</a> - Expresión regular global</span></li>
    <li><span class="function"><a href="#function.preg-filter" class="function" rel="rdfs-seeAlso">preg_filter()</a> - Búsqueda y reemplazo con una expresión regular</span></li>
    <li><span class="function"><a href="#function.preg-last-error" class="function" rel="rdfs-seeAlso">preg_last_error()</a> - Devuelve el código de error de la última expresión PCRE ejecutada</span></li>
   </ul>
  
 </div>


</div>
<hr>







<div id="function.preg-last-error" class="refentry"><hr>
 <div class="refnamediv">
  <h1 class="refname">preg_last_error</h1>
  <p class="verinfo">(PHP 5 &gt;= 5.2.0, PHP 7, PHP 8)</p><p class="refpurpose"><span class="refname">preg_last_error</span> — <span class="dc-title">Devuelve el código de error de la última expresión PCRE ejecutada</span></p>

 </div>

 <div class="refsect1 description" id="refsect1-function.preg-last-error-description">
  <h3 class="title">Descripción</h3>
  <div class="methodsynopsis dc-description">
   <span class="methodname"><strong>preg_last_error</strong></span>(): <span class="type"><a href="#language.types.integer" class="type int">int</a></span></div>

  <p class="para rdfs-comment">
   Devuelve el código de error de la última expresión regular PCRE ejecutada.
  </p>
  <p class="para">
   </p><div class="example" id="example-5037">
    <p><strong>Ejemplo #1 Ejemplo con <span class="function"><strong>preg_last_error()</strong></span></strong></p>
    <div class="example-contents">
<div class="annotation-interactive phpcode"><code><span style="color: #000000"><span style="color: #0000BB">&lt;?php<br><br>preg_match</span><span style="color: #007700">(</span><span style="color: #DD0000">'/(?:\D+|&lt;\d+&gt;)*[!?]/'</span><span style="color: #007700">, </span><span style="color: #DD0000">'foobar foobar foobar'</span><span style="color: #007700">);<br><br>if (</span><span style="color: #0000BB">preg_last_error</span><span style="color: #007700">() == </span><span style="color: #0000BB">PREG_BACKTRACK_LIMIT_ERROR</span><span style="color: #007700">) {<br>    echo </span><span style="color: #DD0000">'Backtrack limit was exhausted!'</span><span style="color: #007700">;<br>}<br><br></span><span style="color: #0000BB">?&gt;</span></span></code></div>
    </div>

    <div class="example-contents"><p>El ejemplo anterior mostrará:</p></div>
    <div class="example-contents screen">
<div class="annotation-interactive descriptioncode"><pre class="descriptioncode">Backtrack limit was exhausted!</pre>
</div>
    </div>
   </div>
  
 </div>


 <div class="refsect1 parameters" id="refsect1-function.preg-last-error-parameters">
  <h3 class="title">Parámetros</h3>
  <p class="para">Esta función no contiene ningún parámetro.</p>
 </div>


 <div class="refsect1 returnvalues" id="refsect1-function.preg-last-error-returnvalues">
  <h3 class="title">Valores devueltos</h3>
  <p class="para">
   Devuelve una de las siguientes constantes (<a href="#pcre.constants" class="link">explicadas en esta página</a>):
   </p><ul class="simplelist">
    <li><strong><code><a href="#constant.preg-no-error">PREG_NO_ERROR</a></code></strong></li>
    <li><strong><code><a href="#constant.preg-internal-error">PREG_INTERNAL_ERROR</a></code></strong></li>
    <li><strong><code><a href="#constant.preg-backtrack-limit-error">PREG_BACKTRACK_LIMIT_ERROR</a></code></strong> (ver también <a href="#ini.pcre.backtrack-limit" class="link">pcre.backtrack_limit</a>)</li>
    <li><strong><code><a href="#constant.preg-recursion-limit-error">PREG_RECURSION_LIMIT_ERROR</a></code></strong> (ver también <a href="#ini.pcre.recursion-limit" class="link">pcre.recursion_limit</a>)</li>
    <li><strong><code><a href="#constant.preg-bad-utf8-error">PREG_BAD_UTF8_ERROR</a></code></strong></li>
    <li><strong><code><a href="#constant.preg-bad-utf8-offset-error">PREG_BAD_UTF8_OFFSET_ERROR</a></code></strong></li>
    <li><strong><code><a href="#constant.preg-jit-stacklimit-error">PREG_JIT_STACKLIMIT_ERROR</a></code></strong></li>
   </ul>
  
 </div>


 <div class="refsect1 seealso" id="refsect1-function.preg-last-error-seealso">
  <h3 class="title">Ver también</h3>
  <p class="para">
   </p><ul class="simplelist">
    <li><span class="function"><a href="#function.preg-last-error-msg" class="function" rel="rdfs-seeAlso">preg_last_error_msg()</a> - Devuelve el mensaje de error de la última ejecución de regex PCRE</span></li>
   </ul>
  
 </div>


</div>
<hr>






<div id="function.preg-last-error-msg" class="refentry"><hr>
 <div class="refnamediv">
  <h1 class="refname">preg_last_error_msg</h1>
  <p class="verinfo">(PHP 8)</p><p class="refpurpose"><span class="refname">preg_last_error_msg</span> — <span class="dc-title">Devuelve el mensaje de error de la última ejecución de regex PCRE</span></p>

 </div>

 <div class="refsect1 description" id="refsect1-function.preg-last-error-msg-description">
  <h3 class="title">Descripción</h3>
  <div class="methodsynopsis dc-description">
   <span class="methodname"><strong>preg_last_error_msg</strong></span>(): <span class="type"><a href="#language.types.string" class="type string">string</a></span></div>

  <p class="para rdfs-comment">
   Devuelve el mensaje de error de la última ejecución de regex PCRE.
  </p>
 </div>


 <div class="refsect1 parameters" id="refsect1-function.preg-last-error-msg-parameters">
  <h3 class="title">Parámetros</h3>
  <p class="para">Esta función no contiene ningún parámetro.</p>
 </div>


 <div class="refsect1 returnvalues" id="refsect1-function.preg-last-error-msg-returnvalues">
  <h3 class="title">Valores devueltos</h3>
  <p class="para">
   Devuelve el mensaje de error en caso de éxito, o <code class="literal">"No error"</code> si no se
   ha producido ningún error.
  </p>
 </div>


 <div class="refsect1 examples" id="refsect1-function.preg-last-error-msg-examples">
  <h3 class="title">Ejemplos</h3>
  <p class="para">
   </p><div class="example" id="example-5038">
    <p><strong>Ejemplo #1 Ejemplo de <span class="function"><strong>preg_last_error_msg()</strong></span></strong></p>
    <div class="example-contents">
<div class="annotation-interactive phpcode"><code><span style="color: #000000"><span style="color: #0000BB">&lt;?php<br><br>preg_match</span><span style="color: #007700">(</span><span style="color: #DD0000">'/(?:\D+|&lt;\d+&gt;)*[!?]/'</span><span style="color: #007700">, </span><span style="color: #DD0000">'foobar foobar foobar'</span><span style="color: #007700">);<br><br>if (</span><span style="color: #0000BB">preg_last_error</span><span style="color: #007700">() !== </span><span style="color: #0000BB">PREG_NO_ERROR</span><span style="color: #007700">) {<br>    echo </span><span style="color: #0000BB">preg_last_error_msg</span><span style="color: #007700">();<br>}<br><br></span><span style="color: #0000BB">?&gt;</span></span></code></div>
    </div>

    <div class="example-contents"><p>El ejemplo anterior mostrará:</p></div>
    <div class="example-contents screen">
<div class="annotation-interactive examplescode"><pre class="examplescode">Backtrack limit exhausted</pre>
</div>
    </div>
   </div>
  
 </div>


 <div class="refsect1 seealso" id="refsect1-function.preg-last-error-msg-seealso">
  <h3 class="title">Ver también</h3>
  <p class="para">
   </p><ul class="simplelist">
    <li><span class="function"><a href="#function.preg-last-error" class="function" rel="rdfs-seeAlso">preg_last_error()</a> - Devuelve el código de error de la última expresión PCRE ejecutada</span></li>
   </ul>
  
 </div>


</div>
<hr>








<div id="function.preg-match" class="refentry"><hr>
 <div class="refnamediv">
  <h1 class="refname">preg_match</h1>
  <p class="verinfo">(PHP 4, PHP 5, PHP 7, PHP 8)</p><p class="refpurpose"><span class="refname">preg_match</span> — <span class="dc-title">Realiza una búsqueda de coincidencia con una expresión regular estándar</span></p>

 </div>

 <div class="refsect1 description" id="refsect1-function.preg-match-description">
  <h3 class="title">Descripción</h3>
  <div class="methodsynopsis dc-description">
   <span class="methodname"><strong>preg_match</strong></span>(<br>    <span class="methodparam"><span class="type"><a href="#language.types.string" class="type string">string</a></span> <code class="parameter">$pattern</code></span>,<br>    <span class="methodparam"><span class="type"><a href="#language.types.string" class="type string">string</a></span> <code class="parameter">$subject</code></span>,<br>    <span class="methodparam"><span class="type"><a href="#language.types.array" class="type array">array</a></span> <code class="parameter reference">&amp;$matches</code><span class="initializer"> = <strong><code><a href="#constant.null">null</a></code></strong></span></span>,<br>    <span class="methodparam"><span class="type"><a href="#language.types.integer" class="type int">int</a></span> <code class="parameter">$flags</code><span class="initializer"> = 0</span></span>,<br>    <span class="methodparam"><span class="type"><a href="#language.types.integer" class="type int">int</a></span> <code class="parameter">$offset</code><span class="initializer"> = 0</span></span><br>): <span class="type"><span class="type"><a href="#language.types.integer" class="type int">int</a></span>|<span class="type"><a href="#language.types.singleton" class="type false">false</a></span></span></div>

  <p class="para rdfs-comment">
   Analiza <code class="parameter">subject</code> para encontrar la expresión que
   coincide con <code class="parameter">pattern</code>.
  </p>
 </div>


 <div class="refsect1 parameters" id="refsect1-function.preg-match-parameters">
  <h3 class="title">Parámetros</h3>
  <p class="para">
   </p><dl>
    
     <dt><code class="parameter">pattern</code></dt>
     <dd>
      <p class="para">
       El patrón a buscar, en forma de <span class="type"><a href="#language.types.string" class="type string">string</a></span>.
      </p>
     </dd>
    
    
     <dt><code class="parameter">subject</code></dt>
     <dd>
      <p class="para">
       La cadena de entrada.
      </p>
     </dd>
    
    
     <dt><code class="parameter">matches</code></dt>
     <dd>
      <p class="para">
       Si <code class="parameter">matches</code> es proporcionado, será llenado con
       los resultados de la búsqueda. <var class="varname">$matches[0]</var> contendrá el
       texto que satisface el patrón completo, <var class="varname">$matches[1]</var> contendrá
       el texto que satisface la primera subexpresión capturante,
       etc.
      </p>
     </dd>
    
    
     <dt><code class="parameter">flags</code></dt>
     <dd>
      <p class="para">
       El parámetro <code class="parameter">flags</code> puede ser una combinación de los siguientes flags:
       </p><dl>
        
         <dt><strong><code><a href="#constant.preg-offset-capture">PREG_OFFSET_CAPTURE</a></code></strong></dt>
         <dd>
          <p class="para">
           Si esta opción está activada, todas las subcadenas que satisfacen
           el patrón también serán identificadas por su offset (en bytes). Tenga en cuenta que esto
           modifica el valor de <code class="parameter">matches</code> que se convierte en
           un array donde cada elemento es un array que contiene la cadena
           que coincide con el patrón en el offset <code class="literal">0</code> así
           como el offset de la cadena en <code class="parameter">subject</code>
           en el offset <code class="literal">1</code>.
           </p><div class="informalexample">
            <div class="example-contents">
<div class="annotation-interactive phpcode"><code><span style="color: #000000"><span style="color: #0000BB">&lt;?php<br>preg_match</span><span style="color: #007700">(</span><span style="color: #DD0000">'/(foo)(bar)(baz)/'</span><span style="color: #007700">, </span><span style="color: #DD0000">'foobarbaz'</span><span style="color: #007700">, </span><span style="color: #0000BB">$matches</span><span style="color: #007700">, </span><span style="color: #0000BB">PREG_OFFSET_CAPTURE</span><span style="color: #007700">);<br></span><span style="color: #0000BB">print_r</span><span style="color: #007700">(</span><span style="color: #0000BB">$matches</span><span style="color: #007700">);<br></span><span style="color: #0000BB">?&gt;</span></span></code></div>
            </div>

            <p class="para">El ejemplo anterior mostrará:</p>
            <div class="example-contents screen">
<div class="annotation-interactive parameterscode"><pre class="parameterscode">Array
(
    [0] =&gt; Array
        (
            [0] =&gt; foobarbaz
            [1] =&gt; 0
        )

    [1] =&gt; Array
        (
            [0] =&gt; foo
            [1] =&gt; 0
        )

    [2] =&gt; Array
        (
            [0] =&gt; bar
            [1] =&gt; 3
        )

    [3] =&gt; Array
        (
            [0] =&gt; baz
            [1] =&gt; 6
        )

)</pre>
</div>
            </div>
           </div>
          
         </dd>
        
        
         <dt><strong><code><a href="#constant.preg-unmatched-as-null">PREG_UNMATCHED_AS_NULL</a></code></strong></dt>
         <dd>
          <p class="para">
           Si este flag es pasado, los subpatrones no coincidentes son reportados como <strong><code><a href="#constant.null">null</a></code></strong>;
           de lo contrario son reportados como <span class="type"><a href="#language.types.string" class="type string">string</a></span> vacío.
           </p><div class="informalexample">
            <div class="example-contents">
<div class="annotation-interactive phpcode"><code><span style="color: #000000"><span style="color: #0000BB">&lt;?php<br>preg_match</span><span style="color: #007700">(</span><span style="color: #DD0000">'/(a)(b)*(c)/'</span><span style="color: #007700">, </span><span style="color: #DD0000">'ac'</span><span style="color: #007700">, </span><span style="color: #0000BB">$matches</span><span style="color: #007700">);<br></span><span style="color: #0000BB">var_dump</span><span style="color: #007700">(</span><span style="color: #0000BB">$matches</span><span style="color: #007700">);<br></span><span style="color: #0000BB">preg_match</span><span style="color: #007700">(</span><span style="color: #DD0000">'/(a)(b)*(c)/'</span><span style="color: #007700">, </span><span style="color: #DD0000">'ac'</span><span style="color: #007700">, </span><span style="color: #0000BB">$matches</span><span style="color: #007700">, </span><span style="color: #0000BB">PREG_UNMATCHED_AS_NULL</span><span style="color: #007700">);<br></span><span style="color: #0000BB">var_dump</span><span style="color: #007700">(</span><span style="color: #0000BB">$matches</span><span style="color: #007700">);<br></span><span style="color: #0000BB">?&gt;</span></span></code></div>
            </div>

            <p class="para">El ejemplo anterior mostrará:</p>
            <div class="example-contents screen">
<div class="annotation-interactive parameterscode"><pre class="parameterscode">array(4) {
  [0]=&gt;
  string(2) "ac"
  [1]=&gt;
  string(1) "a"
  [2]=&gt;
  string(0) ""
  [3]=&gt;
  string(1) "c"
}
array(4) {
  [0]=&gt;
  string(2) "ac"
  [1]=&gt;
  string(1) "a"
  [2]=&gt;
  NULL
  [3]=&gt;
  string(1) "c"
}</pre>
</div>
            </div>
           </div>
          
         </dd>
        
       </dl>
      
     </dd>
    
    
     <dt><code class="parameter">offset</code></dt>
     <dd>
      <p class="para">
       Normalmente, la búsqueda comienza al inicio de la cadena
       <code class="parameter">subject</code>. El parámetro opcional
       <code class="parameter">offset</code> puede ser utilizado para especificar
       una posición para el inicio de la búsqueda (en bytes).
      </p>
      <blockquote class="note"><p><strong class="note">Nota</strong>: 
       </p><p class="para">
        Utilizar el parámetro <code class="parameter">offset</code> no es equivalente
        a pasar <code class="code">substr($subject, $offset)</code> a
        <span class="function"><a href="#function.preg-match-all" class="function">preg_match_all()</a></span> en lugar de la cadena
        <code class="parameter">subject</code>, ya que
        <code class="parameter">pattern</code> puede contener aserciones como
        <em>^</em>, <em>$</em> o
        <em>(?&lt;=x)</em>.
        Compare:
        </p><div class="informalexample">
         <div class="example-contents">
<div class="annotation-interactive phpcode"><code><span style="color: #000000"><span style="color: #0000BB">&lt;?php<br>$subject </span><span style="color: #007700">= </span><span style="color: #DD0000">"abcdef"</span><span style="color: #007700">;<br></span><span style="color: #0000BB">$pattern </span><span style="color: #007700">= </span><span style="color: #DD0000">'/^def/'</span><span style="color: #007700">;<br></span><span style="color: #0000BB">preg_match</span><span style="color: #007700">(</span><span style="color: #0000BB">$pattern</span><span style="color: #007700">, </span><span style="color: #0000BB">$subject</span><span style="color: #007700">, </span><span style="color: #0000BB">$matches</span><span style="color: #007700">, </span><span style="color: #0000BB">PREG_OFFSET_CAPTURE</span><span style="color: #007700">, </span><span style="color: #0000BB">3</span><span style="color: #007700">);<br></span><span style="color: #0000BB">print_r</span><span style="color: #007700">(</span><span style="color: #0000BB">$matches</span><span style="color: #007700">);<br></span><span style="color: #0000BB">?&gt;</span></span></code></div>
         </div>

         <p class="para">El ejemplo anterior mostrará:</p>
         <div class="example-contents screen">
<div class="annotation-interactive cdata"><pre>
Array
(
)
</pre></div>
         </div>
         <p class="para">
          con este ejemplo:
         </p>
         <div class="example-contents">
<div class="annotation-interactive phpcode"><code><span style="color: #000000"><span style="color: #0000BB">&lt;?php<br>$subject </span><span style="color: #007700">= </span><span style="color: #DD0000">"abcdef"</span><span style="color: #007700">;<br></span><span style="color: #0000BB">$pattern </span><span style="color: #007700">= </span><span style="color: #DD0000">'/^def/'</span><span style="color: #007700">;<br></span><span style="color: #0000BB">preg_match</span><span style="color: #007700">(</span><span style="color: #0000BB">$pattern</span><span style="color: #007700">, </span><span style="color: #0000BB">substr</span><span style="color: #007700">(</span><span style="color: #0000BB">$subject</span><span style="color: #007700">,</span><span style="color: #0000BB">3</span><span style="color: #007700">), </span><span style="color: #0000BB">$matches</span><span style="color: #007700">, </span><span style="color: #0000BB">PREG_OFFSET_CAPTURE</span><span style="color: #007700">);<br></span><span style="color: #0000BB">print_r</span><span style="color: #007700">(</span><span style="color: #0000BB">$matches</span><span style="color: #007700">);<br></span><span style="color: #0000BB">?&gt;</span></span></code></div>
         </div>

         <p class="para">
          producirá:
         </p>
         <div class="example-contents screen">
<div class="annotation-interactive cdata"><pre>
Array
(
    [0] =&gt; Array
        (
            [0] =&gt; def
            [1] =&gt; 0
        )

)
</pre></div>
         </div>
         <p class="para">
          Por lo tanto, para evitar el uso de <span class="function"><a href="#function.substr" class="function">substr()</a></span>, utilizar
          la aserción <code class="literal">\G</code> en lugar del ancla <code class="literal">^</code>, o
          el modificador <code class="literal">A</code>, ambos funcionan con el parámetro <code class="parameter">offset</code>.
         </p>
        </div>
       
      </blockquote>
     </dd>
    
   </dl>
  
 </div>


 <div class="refsect1 returnvalues" id="refsect1-function.preg-match-returnvalues">
  <h3 class="title">Valores devueltos</h3>
  <p class="para">
   <span class="function"><strong>preg_match()</strong></span> devuelve 1 si el <code class="parameter">pattern</code>
   proporcionado coincide, 0 si no coincide, o <strong><code><a href="#constant.false">false</a></code></strong> si ocurre un error.
  </p>
  <div class="warning"><strong class="warning">Advertencia</strong><p class="simpara">
 Esta función puede retornar <strong><code><a href="#constant.false">false</a></code></strong>, pero también puede retornar un valor equivalente a <strong><code><a href="#constant.false">false</a></code></strong>.
 Por favor, lea la sección sobre los <a href="#language.types.boolean" class="link">booleanos</a> para más información.
 Utilice el <a href="#language.operators.comparison" class="link">operador ===</a>
 para probar el valor de retorno exacto de esta función.
</p></div>
 </div>


 <div class="refsect1 errors" id="refsect1-function.preg-match-errors">
  <h3 class="title">Errores/Excepciones</h3>
  <p class="para">
Si el patrón regex pasado no se compila a una regex válida, se emite una <strong><code><a href="#constant.e-warning">E_WARNING</a></code></strong>.
</p>
 </div>


 <div class="refsect1 changelog" id="refsect1-function.preg-match-changelog">
  <h3 class="title">Historial de cambios</h3>
  <p class="para">
   </p><table class="doctable informaltable">
    
     <thead>
      <tr>
       <th>Versión</th>
       <th>Descripción</th>
      </tr>

     </thead>

     <tbody class="tbody">
      <tr>
       <td>7.2.0</td>
       <td>
        <strong><code><a href="#constant.preg-unmatched-as-null">PREG_UNMATCHED_AS_NULL</a></code></strong> ahora es soportado para el
        parámetro <code class="parameter">$flags</code>.
       </td>
      </tr>

     </tbody>
    
   </table>

  
 </div>


 <div class="refsect1 examples" id="refsect1-function.preg-match-examples">
  <h3 class="title">Ejemplos</h3>
  <p class="para">
   </p><div class="example" id="example-5039">
    <p><strong>Ejemplo #1 Encontrar la cadena "php"</strong></p>
    <div class="example-contents">
<div class="annotation-interactive phpcode"><code><span style="color: #000000"><span style="color: #0000BB">&lt;?php<br></span><span style="color: #FF8000">// El "i" después del delimitador del patrón indica que la búsqueda no será sensible a mayúsculas/minúsculas<br></span><span style="color: #007700">if (</span><span style="color: #0000BB">preg_match</span><span style="color: #007700">(</span><span style="color: #DD0000">"/php/i"</span><span style="color: #007700">, </span><span style="color: #DD0000">"PHP es el mejor lenguaje de script del web."</span><span style="color: #007700">)) {<br>    echo </span><span style="color: #DD0000">"Se encontró un resultado."</span><span style="color: #007700">;<br>} else {<br>    echo </span><span style="color: #DD0000">"No se encontró ningún resultado."</span><span style="color: #007700">;<br>}<br></span><span style="color: #0000BB">?&gt;</span></span></code></div>
    </div>

   </div>
  
  <p class="para">
   </p><div class="example" id="example-5040">
    <p><strong>Ejemplo #2 Encontrar la palabra "web"</strong></p>
    <div class="example-contents">
<div class="annotation-interactive phpcode"><code><span style="color: #000000"><span style="color: #0000BB">&lt;?php<br></span><span style="color: #FF8000">/* \b, en el patrón, indica un límite de palabra, de forma que la palabra<br> "web" sea detectada, y no solo partes de palabras como<br> en "webbing" o "cobweb" */<br></span><span style="color: #007700">if (</span><span style="color: #0000BB">preg_match</span><span style="color: #007700">(</span><span style="color: #DD0000">"/\bweb\b/i"</span><span style="color: #007700">, </span><span style="color: #DD0000">"PHP es el mejor lenguaje de script del web."</span><span style="color: #007700">)) {<br>    echo </span><span style="color: #DD0000">"La palabra fue encontrada."</span><span style="color: #007700">;<br>} else {<br>    echo </span><span style="color: #DD0000">"La palabra no fue encontrada."</span><span style="color: #007700">;<br>}<br><br>echo </span><span style="color: #DD0000">"\n"</span><span style="color: #007700">;<br><br>if (</span><span style="color: #0000BB">preg_match</span><span style="color: #007700">(</span><span style="color: #DD0000">"/\bweb\b/i"</span><span style="color: #007700">, </span><span style="color: #DD0000">"PHP es el mejor lenguaje de script del web."</span><span style="color: #007700">)) {<br>    echo </span><span style="color: #DD0000">"La palabra fue encontrada."</span><span style="color: #007700">;<br>} else {<br>    echo </span><span style="color: #DD0000">"La palabra no fue encontrada."</span><span style="color: #007700">;<br>}<br></span><span style="color: #0000BB">?&gt;</span></span></code></div>
    </div>

   </div>
  
  <p class="para">
   </p><div class="example" id="example-5041">
    <p><strong>Ejemplo #3 Leer un nombre de dominio en una URL</strong></p>
    <div class="example-contents">
<div class="annotation-interactive phpcode"><code><span style="color: #000000"><span style="color: #0000BB">&lt;?php<br></span><span style="color: #FF8000">// detectar el nombre del host en la URL<br></span><span style="color: #0000BB">preg_match</span><span style="color: #007700">(</span><span style="color: #DD0000">'@^(?:http://)?([^/]+)@i'</span><span style="color: #007700">,<br>    </span><span style="color: #DD0000">"http://www.php.net/index.html"</span><span style="color: #007700">, </span><span style="color: #0000BB">$matches</span><span style="color: #007700">);<br></span><span style="color: #0000BB">$host </span><span style="color: #007700">= </span><span style="color: #0000BB">$matches</span><span style="color: #007700">[</span><span style="color: #0000BB">1</span><span style="color: #007700">];<br><br></span><span style="color: #FF8000">// detectar los dos últimos segmentos del nombre del host<br></span><span style="color: #0000BB">preg_match</span><span style="color: #007700">(</span><span style="color: #DD0000">'/[^.]+\.[^.]+$/'</span><span style="color: #007700">, </span><span style="color: #0000BB">$host</span><span style="color: #007700">, </span><span style="color: #0000BB">$matches</span><span style="color: #007700">);<br>echo </span><span style="color: #DD0000">"El nombre de dominio es: </span><span style="color: #007700">{</span><span style="color: #0000BB">$matches</span><span style="color: #007700">[</span><span style="color: #0000BB">0</span><span style="color: #007700">]}</span><span style="color: #DD0000">\n"</span><span style="color: #007700">;<br></span><span style="color: #0000BB">?&gt;</span></span></code></div>
    </div>

    <div class="example-contents"><p>El ejemplo anterior mostrará:</p></div>
    <div class="example-contents screen">
<div class="annotation-interactive examplescode"><pre class="examplescode">El nombre de dominio es: php.net</pre>
</div>
    </div>
   </div>
  
  <p class="para">
   </p><div class="example" id="example-5042">
    <p><strong>Ejemplo #4 Uso de subpatrones nombrados</strong></p>
    <div class="example-contents">
<div class="annotation-interactive phpcode"><code><span style="color: #000000"><span style="color: #0000BB">&lt;?php<br><br>$str </span><span style="color: #007700">= </span><span style="color: #DD0000">'foobar: 2008'</span><span style="color: #007700">;<br><br></span><span style="color: #0000BB">preg_match</span><span style="color: #007700">(</span><span style="color: #DD0000">'/(?P&lt;name&gt;\w+): (?P&lt;digit&gt;\d+)/'</span><span style="color: #007700">, </span><span style="color: #0000BB">$str</span><span style="color: #007700">, </span><span style="color: #0000BB">$matches</span><span style="color: #007700">);<br><br></span><span style="color: #FF8000">/* Alternativa */<br>// preg_match('/(?&lt;name&gt;\w+): (?&lt;digit&gt;\d+)/', $str, $matches);<br><br></span><span style="color: #0000BB">print_r</span><span style="color: #007700">(</span><span style="color: #0000BB">$matches</span><span style="color: #007700">);<br><br></span><span style="color: #0000BB">?&gt;</span></span></code></div>
    </div>

    <div class="example-contents"><p>El ejemplo anterior mostrará:</p></div>
    <div class="example-contents screen">
<div class="annotation-interactive examplescode"><pre class="examplescode">Array
(
    [0] =&gt; foobar: 2008
    [name] =&gt; foobar
    [1] =&gt; foobar
    [digit] =&gt; 2008
    [2] =&gt; 2008
)</pre>
</div>
    </div>
   </div>
  
 </div>


 <div class="refsect1 notes" id="refsect1-function.preg-match-notes">
  <h3 class="title">Notas</h3>
  <div class="tip"><strong class="tip">Sugerencia</strong>
   <p class="para">
    No utilice <span class="function"><strong>preg_match()</strong></span> si solo desea
    saber si una cadena está contenida en otra.
    Utilice <span class="function"><a href="#function.strpos" class="function">strpos()</a></span> en su lugar, ya que será más rápido.
   </p>
  </div>
 </div>


 <div class="refsect1 seealso" id="refsect1-function.preg-match-seealso">
  <h3 class="title">Ver también</h3>
  <p class="para">
   </p><ul class="simplelist">
    <li><a href="#pcre.pattern" class="link">Patrones PCRE</a></li>
    <li><span class="function"><a href="#function.preg-quote" class="function" rel="rdfs-seeAlso">preg_quote()</a> - Protección de caracteres especiales de expresiones regulares</span></li>
    <li><span class="function"><a href="#function.preg-match-all" class="function" rel="rdfs-seeAlso">preg_match_all()</a> - Expresión regular global</span></li>
    <li><span class="function"><a href="#function.preg-replace" class="function" rel="rdfs-seeAlso">preg_replace()</a> - Buscar y reemplazar mediante expresión regular estándar</span></li>
    <li><span class="function"><a href="#function.preg-split" class="function" rel="rdfs-seeAlso">preg_split()</a> - Divide una cadena mediante expresión regular</span></li>
    <li><span class="function"><a href="#function.preg-last-error" class="function" rel="rdfs-seeAlso">preg_last_error()</a> - Devuelve el código de error de la última expresión PCRE ejecutada</span></li>
    <li><span class="function"><a href="#function.preg-last-error-msg" class="function" rel="rdfs-seeAlso">preg_last_error_msg()</a> - Devuelve el mensaje de error de la última ejecución de regex PCRE</span></li>
   </ul>
  
 </div>


</div>
<hr>







<div id="function.preg-match-all" class="refentry"><hr>
 <div class="refnamediv">
  <h1 class="refname">preg_match_all</h1>
  <p class="verinfo">(PHP 4, PHP 5, PHP 7, PHP 8)</p><p class="refpurpose"><span class="refname">preg_match_all</span> — <span class="dc-title">Expresión regular global</span></p>

 </div>

 <div class="refsect1 description" id="refsect1-function.preg-match-all-description">
  <h3 class="title">Descripción</h3>
  <div class="methodsynopsis dc-description">
   <span class="methodname"><strong>preg_match_all</strong></span>(<br>    <span class="methodparam"><span class="type"><a href="#language.types.string" class="type string">string</a></span> <code class="parameter">$pattern</code></span>,<br>    <span class="methodparam"><span class="type"><a href="#language.types.string" class="type string">string</a></span> <code class="parameter">$subject</code></span>,<br>    <span class="methodparam"><span class="type"><a href="#language.types.array" class="type array">array</a></span> <code class="parameter reference">&amp;$matches</code><span class="initializer"> = <strong><code><a href="#constant.null">null</a></code></strong></span></span>,<br>    <span class="methodparam"><span class="type"><a href="#language.types.integer" class="type int">int</a></span> <code class="parameter">$flags</code><span class="initializer"> = 0</span></span>,<br>    <span class="methodparam"><span class="type"><a href="#language.types.integer" class="type int">int</a></span> <code class="parameter">$offset</code><span class="initializer"> = 0</span></span><br>): <span class="type"><span class="type"><a href="#language.types.integer" class="type int">int</a></span>|<span class="type"><a href="#language.types.singleton" class="type false">false</a></span></span></div>

  <p class="para rdfs-comment">
   Analiza <code class="parameter">subject</code> para encontrar la expresión
   <code class="parameter">pattern</code> y almacena los resultados en
   <code class="parameter">matches</code>, en el orden especificado por
   <code class="parameter">flags</code>.
  </p>
  <p class="para">
   Tras encontrar un primer resultado, la búsqueda continúa hasta
   el final de la cadena.
  </p>
 </div>


 <div class="refsect1 parameters" id="refsect1-function.preg-match-all-parameters">
  <h3 class="title">Parámetros</h3>
  <p class="para">
   </p><dl>
    
     <dt><code class="parameter">pattern</code></dt>
     <dd>
      <p class="para">
       La máscara a buscar, en forma de <span class="type"><a href="#language.types.string" class="type string">string</a></span>.
      </p>
     </dd>
    
    
     <dt><code class="parameter">subject</code></dt>
     <dd>
      <p class="para">
       La cadena de entrada.
      </p>
     </dd>
    
    
     <dt><code class="parameter">matches</code></dt>
     <dd>
      <p class="para">
       Array que contiene todos los resultados, en un array multidimensional ordenado
       según el parámetro <code class="parameter">flags</code>.
      </p>
     </dd>
    
    
     <dt><code class="parameter">flags</code></dt>
     <dd>
      <p class="para">
       Puede ser una combinación de los siguientes valores
       (señalando que es incoherente usar
       <strong><code><a href="#constant.preg-pattern-order">PREG_PATTERN_ORDER</a></code></strong> con
       <strong><code><a href="#constant.preg-set-order">PREG_SET_ORDER</a></code></strong> ) :
       </p><dl>
        
         <dt><strong><code><a href="#constant.preg-pattern-order">PREG_PATTERN_ORDER</a></code></strong></dt>
         <dd>
          <p class="para">
           El orden es tal que <var class="varname">$matches[0]</var> es un array que
           contiene los resultados que satisfacen la máscara
           completa, <var class="varname">$matches[1]</var> es un array que contiene los
           resultados que satisfacen la primera
           subexpresión capturante, etc.
          </p>
          <p class="para">
           </p><div class="informalexample">
            <div class="example-contents">
<div class="annotation-interactive phpcode"><code><span style="color: #000000"><span style="color: #0000BB">&lt;?php<br>preg_match_all</span><span style="color: #007700">(</span><span style="color: #DD0000">"|&lt;[^&gt;]+&gt;(.*)&lt;/[^&gt;]+&gt;|U"</span><span style="color: #007700">,<br>    </span><span style="color: #DD0000">"&lt;b&gt;ejemplo : &lt;/b&gt;&lt;div align=left&gt;esto es una prueba&lt;/div&gt;"</span><span style="color: #007700">,<br>    </span><span style="color: #0000BB">$out</span><span style="color: #007700">, </span><span style="color: #0000BB">PREG_PATTERN_ORDER</span><span style="color: #007700">);<br>echo </span><span style="color: #0000BB">$out</span><span style="color: #007700">[</span><span style="color: #0000BB">0</span><span style="color: #007700">][</span><span style="color: #0000BB">0</span><span style="color: #007700">] . </span><span style="color: #DD0000">", " </span><span style="color: #007700">. </span><span style="color: #0000BB">$out</span><span style="color: #007700">[</span><span style="color: #0000BB">0</span><span style="color: #007700">][</span><span style="color: #0000BB">1</span><span style="color: #007700">] . </span><span style="color: #DD0000">"\n"</span><span style="color: #007700">;<br>echo </span><span style="color: #0000BB">$out</span><span style="color: #007700">[</span><span style="color: #0000BB">1</span><span style="color: #007700">][</span><span style="color: #0000BB">0</span><span style="color: #007700">] . </span><span style="color: #DD0000">", " </span><span style="color: #007700">. </span><span style="color: #0000BB">$out</span><span style="color: #007700">[</span><span style="color: #0000BB">1</span><span style="color: #007700">][</span><span style="color: #0000BB">1</span><span style="color: #007700">] . </span><span style="color: #DD0000">"\n"</span><span style="color: #007700">;<br></span><span style="color: #0000BB">?&gt;</span></span></code></div>
            </div>

            <p class="para">El ejemplo anterior mostrará:</p>
            <div class="example-contents screen">
<div class="annotation-interactive parameterscode"><pre class="parameterscode">&lt;b&gt;ejemplo : &lt;/b&gt;, &lt;div align=left&gt;esto es una prueba&lt;/div&gt;
ejemplo : , esto es una prueba</pre>
</div>
            </div>
            <p class="para">
             Así, <var class="varname">$out[0]</var> es un array que contiene los resultados que
             satisfacen la máscara completa, y <var class="varname">$out[1]</var> es un array que contiene
             las etiquetas entre &gt; y &lt;.
            </p>
           </div>
          
          <p class="para">
           Si la máscara contiene submáscaras nombradas, <var class="varname">$matches</var>
           contendrá además entradas que tendrán como claves los nombres de las submáscaras.
          </p>
          <p class="para">
           Si la máscara contiene submáscaras nombradas duplicadas, solo la submáscara
           más a la derecha será registrada en <var class="varname">$matches[NAME]</var>.
           </p><div class="informalexample">
            <div class="example-contents">
<div class="annotation-interactive phpcode"><code><span style="color: #000000"><span style="color: #0000BB">&lt;?php<br>preg_match_all</span><span style="color: #007700">(<br>    </span><span style="color: #DD0000">'/(?J)(?&lt;match&gt;foo)|(?&lt;match&gt;bar)/'</span><span style="color: #007700">,<br>    </span><span style="color: #DD0000">'foo bar'</span><span style="color: #007700">,<br>    </span><span style="color: #0000BB">$matches</span><span style="color: #007700">,<br>    </span><span style="color: #0000BB">PREG_PATTERN_ORDER<br></span><span style="color: #007700">);<br></span><span style="color: #0000BB">print_r</span><span style="color: #007700">(</span><span style="color: #0000BB">$matches</span><span style="color: #007700">[</span><span style="color: #DD0000">'match'</span><span style="color: #007700">]);<br></span><span style="color: #0000BB">?&gt;</span></span></code></div>
            </div>

            <p class="para">El ejemplo anterior mostrará:</p>
            <div class="example-contents screen">
<div class="annotation-interactive parameterscode"><pre class="parameterscode">Array
(
    [0] =&gt;
    [1] =&gt; bar
)</pre>
</div>
            </div>
           </div>
          
         </dd>
        
        
         <dt><strong><code><a href="#constant.preg-set-order">PREG_SET_ORDER</a></code></strong></dt>
         <dd>
          <p class="para">
           Los resultados se ordenan de tal forma que <var class="varname">$matches[0]</var>
           contiene la primera serie de resultados, <var class="varname">$matches[1]</var> contiene
           la segunda, etc.
           </p><div class="informalexample">
            <div class="example-contents">
<div class="annotation-interactive phpcode"><code><span style="color: #000000"><span style="color: #0000BB">&lt;?php<br>preg_match_all</span><span style="color: #007700">(</span><span style="color: #DD0000">"|&lt;[^&gt;]+&gt;(.*)&lt;/[^&gt;]+&gt;|U"</span><span style="color: #007700">,<br>    </span><span style="color: #DD0000">"&lt;b&gt;ejemplo : &lt;/b&gt;&lt;div align=\"left\"&gt;esto es una prueba&lt;/div&gt;"</span><span style="color: #007700">,<br>    </span><span style="color: #0000BB">$out</span><span style="color: #007700">, </span><span style="color: #0000BB">PREG_SET_ORDER</span><span style="color: #007700">);<br>echo </span><span style="color: #0000BB">$out</span><span style="color: #007700">[</span><span style="color: #0000BB">0</span><span style="color: #007700">][</span><span style="color: #0000BB">0</span><span style="color: #007700">] . </span><span style="color: #DD0000">", " </span><span style="color: #007700">. </span><span style="color: #0000BB">$out</span><span style="color: #007700">[</span><span style="color: #0000BB">0</span><span style="color: #007700">][</span><span style="color: #0000BB">1</span><span style="color: #007700">] . </span><span style="color: #DD0000">"\n"</span><span style="color: #007700">;<br>echo </span><span style="color: #0000BB">$out</span><span style="color: #007700">[</span><span style="color: #0000BB">1</span><span style="color: #007700">][</span><span style="color: #0000BB">0</span><span style="color: #007700">] . </span><span style="color: #DD0000">", " </span><span style="color: #007700">. </span><span style="color: #0000BB">$out</span><span style="color: #007700">[</span><span style="color: #0000BB">1</span><span style="color: #007700">][</span><span style="color: #0000BB">1</span><span style="color: #007700">] . </span><span style="color: #DD0000">"\n"</span><span style="color: #007700">;<br></span><span style="color: #0000BB">?&gt;</span></span></code></div>
            </div>

            <p class="para">El ejemplo anterior mostrará:</p>
            <div class="example-contents screen">
<div class="annotation-interactive parameterscode"><pre class="parameterscode">&lt;b&gt;ejemplo : &lt;/b&gt;, ejemplo :
&lt;div align="left"&gt;esto es una prueba&lt;/div&gt;, esto es una prueba</pre>
</div>
            </div>
           </div>
          
         </dd>
        
        
         <dt><strong><code><a href="#constant.preg-offset-capture">PREG_OFFSET_CAPTURE</a></code></strong></dt>
         <dd>
          <p class="para">
           Si este flag es pasado, todas las subcadenas que satisfacen
           la máscara también serán identificadas por su offset (en bytes).
           Tenga en cuenta que esto modifica el valor de <code class="parameter">matches</code> en
           un array de arrays donde cada elemento es un array que contiene
           la subcadena satisfecha en el índice <code class="literal">0</code> y el índice de
           esta en la cadena <code class="parameter">subject</code> en el índice <code class="literal">1</code>.
           </p><div class="informalexample">
            <div class="example-contents">
<div class="annotation-interactive phpcode"><code><span style="color: #000000"><span style="color: #0000BB">&lt;?php<br>preg_match_all</span><span style="color: #007700">(</span><span style="color: #DD0000">'/(foo)(bar)(baz)/'</span><span style="color: #007700">, </span><span style="color: #DD0000">'foobarbaz'</span><span style="color: #007700">, </span><span style="color: #0000BB">$matches</span><span style="color: #007700">, </span><span style="color: #0000BB">PREG_OFFSET_CAPTURE</span><span style="color: #007700">);<br></span><span style="color: #0000BB">print_r</span><span style="color: #007700">(</span><span style="color: #0000BB">$matches</span><span style="color: #007700">);<br></span><span style="color: #0000BB">?&gt;</span></span></code></div>
            </div>

            <p class="para">El ejemplo anterior mostrará:</p>
            <div class="example-contents screen">
<div class="annotation-interactive parameterscode"><pre class="parameterscode">Array
(
    [0] =&gt; Array
        (
            [0] =&gt; Array
                (
                    [0] =&gt; foobarbaz
                    [1] =&gt; 0
                )

        )

    [1] =&gt; Array
        (
            [0] =&gt; Array
                (
                    [0] =&gt; foo
                    [1] =&gt; 0
                )

        )

    [2] =&gt; Array
        (
            [0] =&gt; Array
                (
                    [0] =&gt; bar
                    [1] =&gt; 3
                )

        )

    [3] =&gt; Array
        (
            [0] =&gt; Array
                (
                    [0] =&gt; baz
                    [1] =&gt; 6
                )

        )

)</pre>
</div>
            </div>
           </div>
          
         </dd>
        
        
         <dt><strong><code><a href="#constant.preg-unmatched-as-null">PREG_UNMATCHED_AS_NULL</a></code></strong></dt>
         <dd>
          <p class="para">
           Si este flag es pasado, las subexpresiones no satisfechas son reportadas como <strong><code><a href="#constant.null">null</a></code></strong> ;
           de lo contrario, son reportadas como <span class="type"><a href="#language.types.string" class="type string">string</a></span> vacía.
          </p>
         </dd>
        
       </dl>
      
      <p class="para">
       Si <code class="parameter">order</code> es omitido,
       <strong><code><a href="#constant.preg-pattern-order">PREG_PATTERN_ORDER</a></code></strong> es usado por defecto.
      </p>
     </dd>
    
    
     <dt><code class="parameter">offset</code></dt>
     <dd>
      <p class="para">
       Normalmente, la búsqueda comienza al inicio de la cadena
       <code class="parameter">subject</code>. El parámetro opcional
       <code class="parameter">offset</code> puede ser usado para especificar
       una posición para el inicio de la búsqueda (en bytes).
      </p>
      <blockquote class="note"><p><strong class="note">Nota</strong>: 
       </p><p class="para">
        Usar el parámetro <code class="parameter">offset</code> no equivale
        a pasar <code class="code">substr($subject, $offset)</code> a
        <span class="function"><strong>preg_match_all()</strong></span> en lugar de la cadena
        <code class="parameter">subject</code>, ya que
        <code class="parameter">pattern</code> puede contener aserciones como
        <em>^</em>, <em>$</em> o
        <em>(?&lt;=x)</em>. Consulte la documentación
        sobre la función <span class="function"><a href="#function.preg-match" class="function">preg_match()</a></span> para ejemplos.
       </p>
      </blockquote>
     </dd>
    
   </dl>
  
 </div>


 <div class="refsect1 returnvalues" id="refsect1-function.preg-match-all-returnvalues">
  <h3 class="title">Valores devueltos</h3>
  <p class="para">
   Devuelve el número de resultados que satisfacen la máscara
   completa, o <strong><code><a href="#constant.false">false</a></code></strong> si ocurre un error.
  </p>
 </div>


 <div class="refsect1 errors" id="refsect1-function.preg-match-all-errors">
  <h3 class="title">Errores/Excepciones</h3>
  <p class="para">
Si el patrón regex pasado no se compila a una regex válida, se emite una <strong><code><a href="#constant.e-warning">E_WARNING</a></code></strong>.
</p>
 </div>


 <div class="refsect1 changelog" id="refsect1-function.preg-match-all-changelog">
  <h3 class="title">Historial de cambios</h3>
  <p class="para">
   </p><table class="doctable informaltable">
    
     <thead>
      <tr>
       <th>Versión</th>
       <th>Descripción</th>
      </tr>

     </thead>

     <tbody class="tbody">
      <tr>
       <td>7.2.0</td>
       <td>
        <strong><code><a href="#constant.preg-unmatched-as-null">PREG_UNMATCHED_AS_NULL</a></code></strong> es ahora soportado para el
        parámetro <code class="parameter">$flags</code>.
       </td>
      </tr>

     </tbody>
    
   </table>

  
 </div>


 <div class="refsect1 examples" id="refsect1-function.preg-match-all-examples">
  <h3 class="title">Ejemplos</h3>
  <p class="para">
   </p><div class="example" id="example-5043">
    <p><strong>Ejemplo #1 Extracción de todos los números de teléfono de un texto</strong></p>
    <div class="example-contents">
<div class="annotation-interactive phpcode"><code><span style="color: #000000"><span style="color: #0000BB">&lt;?php<br>preg_match_all</span><span style="color: #007700">(</span><span style="color: #DD0000">"/\(?  (\d{3})?  \)?  (?(1)  [\-\s] ) \d{3}-\d{4}/x"</span><span style="color: #007700">,<br>                </span><span style="color: #DD0000">"Llamar al 555-1212 o 1-800-555-1212"</span><span style="color: #007700">, </span><span style="color: #0000BB">$phones</span><span style="color: #007700">);<br></span><span style="color: #0000BB">?&gt;</span></span></code></div>
    </div>

   </div>
  
  <p class="para">
   </p><div class="example" id="example-5044">
    <p><strong>Ejemplo #2 Buscar pares de etiquetas HTML (voraz)</strong></p>
    <div class="example-contents">
<div class="annotation-interactive phpcode"><code><span style="color: #000000"><span style="color: #0000BB">&lt;?php<br></span><span style="color: #FF8000">// Este ejemplo utiliza referencias hacia atrás (\\2).<br>// Indican al analizador que debe encontrar algo que ya ha identificado antes<br>// el número 2 indica que es el segundo juego de paréntesis<br>// capturante que debe ser usado (en este caso, ([\w]+)).<br>// La barra invertida es necesaria aquí, ya que la cadena está entre comillas dobles<br><br></span><span style="color: #0000BB">$html </span><span style="color: #007700">= </span><span style="color: #DD0000">"&lt;b&gt;texto en negrita&lt;/b&gt;&lt;a href=howdy.html&gt;haz clic aquí&lt;/a&gt;"</span><span style="color: #007700">;<br><br></span><span style="color: #0000BB">preg_match_all</span><span style="color: #007700">(</span><span style="color: #DD0000">"/(&lt;([\w]+)[^&gt;]*&gt;)(.*?)(&lt;\/\\2&gt;)/"</span><span style="color: #007700">, </span><span style="color: #0000BB">$html</span><span style="color: #007700">, </span><span style="color: #0000BB">$matches</span><span style="color: #007700">, </span><span style="color: #0000BB">PREG_SET_ORDER</span><span style="color: #007700">);<br><br>foreach (</span><span style="color: #0000BB">$matches </span><span style="color: #007700">as </span><span style="color: #0000BB">$val</span><span style="color: #007700">) {<br>    echo </span><span style="color: #DD0000">"coincidencia: " </span><span style="color: #007700">. </span><span style="color: #0000BB">$val</span><span style="color: #007700">[</span><span style="color: #0000BB">0</span><span style="color: #007700">] . </span><span style="color: #DD0000">"\n"</span><span style="color: #007700">;<br>    echo </span><span style="color: #DD0000">"parte 1: " </span><span style="color: #007700">. </span><span style="color: #0000BB">$val</span><span style="color: #007700">[</span><span style="color: #0000BB">1</span><span style="color: #007700">] . </span><span style="color: #DD0000">"\n"</span><span style="color: #007700">;<br>    echo </span><span style="color: #DD0000">"parte 2: " </span><span style="color: #007700">. </span><span style="color: #0000BB">$val</span><span style="color: #007700">[</span><span style="color: #0000BB">2</span><span style="color: #007700">] . </span><span style="color: #DD0000">"\n"</span><span style="color: #007700">;<br>    echo </span><span style="color: #DD0000">"parte 3: " </span><span style="color: #007700">. </span><span style="color: #0000BB">$val</span><span style="color: #007700">[</span><span style="color: #0000BB">3</span><span style="color: #007700">] . </span><span style="color: #DD0000">"\n"</span><span style="color: #007700">;<br>    echo </span><span style="color: #DD0000">"parte 4: " </span><span style="color: #007700">. </span><span style="color: #0000BB">$val</span><span style="color: #007700">[</span><span style="color: #0000BB">4</span><span style="color: #007700">] . </span><span style="color: #DD0000">"\n\n"</span><span style="color: #007700">;<br>}<br></span><span style="color: #0000BB">?&gt;</span></span></code></div>
    </div>

    <div class="example-contents"><p>El ejemplo anterior mostrará:</p></div>
    <div class="example-contents screen">
<div class="annotation-interactive examplescode"><pre class="examplescode">coincidencia: &lt;b&gt;texto en negrita&lt;/b&gt;
parte 2: b
parte 3: texto en negrita
parte 4: &lt;/b&gt;

coincidencia: &lt;a href=howdy.html&gt;haz clic aquí&lt;/a&gt;
parte 1: &lt;a href=howdy.html&gt;
parte 2: a
parte 3: haz clic aquí
parte 4: &lt;/a&gt;</pre>
</div>
    </div>
   </div>
  
  <p class="para">
   </p><div class="example" id="example-5045">
    <p><strong>Ejemplo #3 Uso de una subexpresión nombrada</strong></p>
    <div class="example-contents">
<div class="annotation-interactive phpcode"><code><span style="color: #000000"><span style="color: #0000BB">&lt;?php<br><br>$str </span><span style="color: #007700">= &lt;&lt;&lt;FOO<br></span><span style="color: #DD0000">a: 1<br>b: 2<br>c: 3<br></span><span style="color: #007700">FOO;<br><br></span><span style="color: #0000BB">preg_match_all</span><span style="color: #007700">(</span><span style="color: #DD0000">'/(?P&lt;name&gt;\w+): (?P&lt;digit&gt;\d+)/'</span><span style="color: #007700">, </span><span style="color: #0000BB">$str</span><span style="color: #007700">, </span><span style="color: #0000BB">$matches</span><span style="color: #007700">);<br><br></span><span style="color: #FF8000">/* Alternativa */<br>// preg_match_all('/(?&lt;name&gt;\w+): (?&lt;digit&gt;\d+)/', $str, $matches);<br><br></span><span style="color: #0000BB">print_r</span><span style="color: #007700">(</span><span style="color: #0000BB">$matches</span><span style="color: #007700">);<br><br></span><span style="color: #0000BB">?&gt;</span></span></code></div>
    </div>

    <div class="example-contents"><p>El ejemplo anterior mostrará:</p></div>
    <div class="example-contents screen">
<div class="annotation-interactive examplescode"><pre class="examplescode">Array
(
    [0] =&gt; Array
        (
            [0] =&gt; a: 1
            [1] =&gt; b: 2
            [2] =&gt; c: 3
        )

    [name] =&gt; Array
        (
            [0] =&gt; a
            [1] =&gt; b
            [2] =&gt; c
        )

    [1] =&gt; Array
        (
            [0] =&gt; a
            [1] =&gt; b
            [2] =&gt; c
        )

    [digit] =&gt; Array
        (
            [0] =&gt; 1
            [1] =&gt; 2
            [2] =&gt; 3
        )

    [2] =&gt; Array
        (
            [0] =&gt; 1
            [1] =&gt; 2
            [2] =&gt; 3
        )

)</pre>
</div>
    </div>
   </div>
  
 </div>


 <div class="refsect1 seealso" id="refsect1-function.preg-match-all-seealso">
  <h3 class="title">Ver también</h3>
  <p class="para">
   </p><ul class="simplelist">
    <li><a href="#pcre.pattern" class="link">Máscaras PCRE</a></li>
    <li><span class="function"><a href="#function.preg-quote" class="function" rel="rdfs-seeAlso">preg_quote()</a> - Protección de caracteres especiales de expresiones regulares</span></li>
    <li><span class="function"><a href="#function.preg-match" class="function" rel="rdfs-seeAlso">preg_match()</a> - Realiza una búsqueda de coincidencia con una expresión regular estándar</span></li>
    <li><span class="function"><a href="#function.preg-replace" class="function" rel="rdfs-seeAlso">preg_replace()</a> - Buscar y reemplazar mediante expresión regular estándar</span></li>
    <li><span class="function"><a href="#function.preg-split" class="function" rel="rdfs-seeAlso">preg_split()</a> - Divide una cadena mediante expresión regular</span></li>
    <li><span class="function"><a href="#function.preg-last-error" class="function" rel="rdfs-seeAlso">preg_last_error()</a> - Devuelve el código de error de la última expresión PCRE ejecutada</span></li>
   </ul>
  
 </div>


</div>
<hr>







<div id="function.preg-quote" class="refentry"><hr>
 <div class="refnamediv">
  <h1 class="refname">preg_quote</h1>
  <p class="verinfo">(PHP 4, PHP 5, PHP 7, PHP 8)</p><p class="refpurpose"><span class="refname">preg_quote</span> — <span class="dc-title">Protección de caracteres especiales de expresiones regulares</span></p>

 </div>

 <div class="refsect1 description" id="refsect1-function.preg-quote-description">
  <h3 class="title">Descripción</h3>
  <div class="methodsynopsis dc-description">
   <span class="methodname"><strong>preg_quote</strong></span>(<span class="methodparam"><span class="type"><a href="#language.types.string" class="type string">string</a></span> <code class="parameter">$str</code></span>, <span class="methodparam"><span class="type"><span class="type"><a href="#language.types.null" class="type null">?</a></span><span class="type"><a href="#language.types.string" class="type string">string</a></span></span> <code class="parameter">$delimiter</code><span class="initializer"> = <strong><code><a href="#constant.null">null</a></code></strong></span></span>): <span class="type"><a href="#language.types.string" class="type string">string</a></span></div>

  <p class="para rdfs-comment">
   <span class="function"><strong>preg_quote()</strong></span> añade una barra invertida antes de cada carácter de la cadena <code class="parameter">str</code> que forma parte de la sintaxis de expresiones regulares.
   Esto es muy útil si se tiene una cadena que va a
   servir como máscara, pero que es generada
   durante la ejecución.
  </p>
  <p class="para">
   Los caracteres especiales que serán protegidos son los siguientes:
   <code class="literal">. \ + * ? [ ^ ] $ ( ) { } = ! &lt; &gt; | : - #</code>
  </p>
  <p class="para">
   Tenga en cuenta que <code class="literal">/</code> no es un carácter especial de expresión regular.
  </p>
  <blockquote class="note"><p><strong class="note">Nota</strong>: 
   </p><p class="para">
    Tenga en cuenta que <span class="function"><strong>preg_quote()</strong></span> no está destinado a ser aplicado a
    las cadenas $replacement de <span class="function"><a href="#function.preg-replace" class="function">preg_replace()</a></span> etc.
   </p>
  </blockquote>
 </div>


 <div class="refsect1 parameters" id="refsect1-function.preg-quote-parameters">
  <h3 class="title">Parámetros</h3>
  <p class="para">
   </p><dl>
    
     <dt><code class="parameter">str</code></dt>
     <dd>
      <p class="para">
       La cadena de entrada.
      </p>
     </dd>
    
    
     <dt><code class="parameter">delimiter</code></dt>
     <dd>
      <p class="para">
       Si el argumento opcional <code class="parameter">delimiter</code> es proporcionado,
       también será escapado. Esto es práctico para escapar
       el delimitador requerido por las funciones PCRE. La barra <code class="literal">/</code> es el
       delimitador más común.
      </p>
     </dd>
    
   </dl>
  
 </div>


 <div class="refsect1 returnvalues" id="refsect1-function.preg-quote-returnvalues">
  <h3 class="title">Valores devueltos</h3>
  <p class="para">
   Retorna la cadena protegida.
  </p>
 </div>


 <div class="refsect1 changelog" id="refsect1-function.preg-quote-changelog">
  <h3 class="title">Historial de cambios</h3>
  <p class="para">
   </p><table class="doctable informaltable">
    
     <thead>
      <tr>
       <th>Versión</th>
       <th>Descripción</th>
      </tr>

     </thead>

     <tbody class="tbody">
      <tr>
       <td>7.3.0</td>
       <td>
        El carácter <code class="literal">#</code> ahora es protegido
       </td>
      </tr>

      <tr>
       <td>7.2.0</td>
       <td>
        <code class="parameter">delimiter</code> ahora es nullable.
       </td>
      </tr>

     </tbody>
    
   </table>

  
 </div>


 <div class="refsect1 examples" id="refsect1-function.preg-quote-examples">
  <h3 class="title">Ejemplos</h3>
  <p class="para">
   </p><div class="example" id="example-5046">
    <p><strong>Ejemplo #1 Ejemplo con <span class="function"><strong>preg_quote()</strong></span></strong></p>
    <div class="example-contents">
<div class="annotation-interactive phpcode"><code><span style="color: #000000"><span style="color: #0000BB">&lt;?php<br>$keywords </span><span style="color: #007700">= </span><span style="color: #DD0000">'$40 para un g3/400'</span><span style="color: #007700">;<br></span><span style="color: #0000BB">$keywords </span><span style="color: #007700">= </span><span style="color: #0000BB">preg_quote</span><span style="color: #007700">(</span><span style="color: #0000BB">$keywords</span><span style="color: #007700">, </span><span style="color: #DD0000">'/'</span><span style="color: #007700">);<br>echo </span><span style="color: #0000BB">$keywords</span><span style="color: #007700">; </span><span style="color: #FF8000">// retorna \$40 para un g3\/400<br></span><span style="color: #0000BB">?&gt;</span></span></code></div>
    </div>

   </div>
  
  <p class="para">
   </p><div class="example" id="example-5047">
    <p><strong>Ejemplo #2 Poner en cursiva una palabra en un texto</strong></p>
    <div class="example-contents">
<div class="annotation-interactive phpcode"><code><span style="color: #000000"><span style="color: #0000BB">&lt;?php<br></span><span style="color: #FF8000">// En este ejemplo, preg_quote($word) sirve para evitar que los asteriscos<br>// tengan un valor especial en la expresión regular.<br><br></span><span style="color: #0000BB">$textbody </span><span style="color: #007700">= </span><span style="color: #DD0000">"Este libro es *muy* difícil de encontrar."</span><span style="color: #007700">;<br></span><span style="color: #0000BB">$word </span><span style="color: #007700">= </span><span style="color: #DD0000">"*muy*"</span><span style="color: #007700">;<br></span><span style="color: #0000BB">$textbody </span><span style="color: #007700">= </span><span style="color: #0000BB">preg_replace </span><span style="color: #007700">(</span><span style="color: #DD0000">"/" </span><span style="color: #007700">. </span><span style="color: #0000BB">preg_quote</span><span style="color: #007700">(</span><span style="color: #0000BB">$word</span><span style="color: #007700">, </span><span style="color: #DD0000">'/'</span><span style="color: #007700">) . </span><span style="color: #DD0000">"/"</span><span style="color: #007700">,<br>                          </span><span style="color: #DD0000">"&lt;i&gt;" </span><span style="color: #007700">. </span><span style="color: #0000BB">$word </span><span style="color: #007700">. </span><span style="color: #DD0000">"&lt;/i&gt;"</span><span style="color: #007700">,<br>                          </span><span style="color: #0000BB">$textbody</span><span style="color: #007700">);<br></span><span style="color: #0000BB">?&gt;</span></span></code></div>
    </div>

   </div>
  
 </div>


 <div class="refsect1 notes" id="refsect1-function.preg-quote-notes">
  <h3 class="title">Notas</h3>
  <blockquote class="note"><p><strong class="note">Nota</strong>: <span class="simpara">Esta función es
segura para sistemas binarios.</span></p></blockquote>
 </div>


 <div class="refsect1 seealso" id="refsect1-function.preg-quote-seealso">
  <h3 class="title">Ver también</h3>
  <p class="para">
   </p><ul class="simplelist">
    <li><a href="#pcre.pattern" class="link">Máscaras PCRE</a></li>
    <li><span class="function"><a href="#function.escapeshellcmd" class="function" rel="rdfs-seeAlso">escapeshellcmd()</a> - Protege los caracteres especiales del Shell</span></li>
   </ul>
  
 </div>


</div>
<hr>







<div id="function.preg-replace" class="refentry"><hr>
 <div class="refnamediv">
  <h1 class="refname">preg_replace</h1>
  <p class="verinfo">(PHP 4, PHP 5, PHP 7, PHP 8)</p><p class="refpurpose"><span class="refname">preg_replace</span> — <span class="dc-title">Buscar y reemplazar mediante expresión regular estándar</span></p>

 </div>

 <div class="refsect1 description" id="refsect1-function.preg-replace-description">
  <h3 class="title">Descripción</h3>
  <div class="methodsynopsis dc-description">
   <span class="methodname"><strong>preg_replace</strong></span>(<br>    <span class="methodparam"><span class="type"><span class="type"><a href="#language.types.string" class="type string">string</a></span>|<span class="type"><a href="#language.types.array" class="type array">array</a></span></span> <code class="parameter">$pattern</code></span>,<br>    <span class="methodparam"><span class="type"><span class="type"><a href="#language.types.string" class="type string">string</a></span>|<span class="type"><a href="#language.types.array" class="type array">array</a></span></span> <code class="parameter">$replacement</code></span>,<br>    <span class="methodparam"><span class="type"><span class="type"><a href="#language.types.string" class="type string">string</a></span>|<span class="type"><a href="#language.types.array" class="type array">array</a></span></span> <code class="parameter">$subject</code></span>,<br>    <span class="methodparam"><span class="type"><a href="#language.types.integer" class="type int">int</a></span> <code class="parameter">$limit</code><span class="initializer"> = -1</span></span>,<br>    <span class="methodparam"><span class="type"><a href="#language.types.integer" class="type int">int</a></span> <code class="parameter reference">&amp;$count</code><span class="initializer"> = <strong><code><a href="#constant.null">null</a></code></strong></span></span><br>): <span class="type"><span class="type"><a href="#language.types.string" class="type string">string</a></span>|<span class="type"><a href="#language.types.array" class="type array">array</a></span>|<span class="type"><a href="#language.types.null" class="type null">null</a></span></span></div>

  <p class="para rdfs-comment">
   Analiza <code class="parameter">subject</code> para encontrar la expresión
   regular <code class="parameter">pattern</code> y reemplaza los
   resultados por <code class="parameter">replacement</code>.
  </p>
  <p class="para">
   Para hacer coincidir una cadena exacta, en lugar de una expresión regular,
   se recomienda el uso de <span class="function"><a href="#function.str-replace" class="function">str_replace()</a></span> o <span class="function"><a href="#function.str-ireplace" class="function">str_ireplace()</a></span>
   en lugar de esta función.
  </p>
 </div>


 <div class="refsect1 parameters" id="refsect1-function.preg-replace-parameters">
  <h3 class="title">Parámetros</h3>
  <p class="para">
   </p><dl>
    
     <dt><code class="parameter">pattern</code></dt>
     <dd>
      <p class="para">
       El patrón a buscar. Puede ser una cadena o un array de cadenas.
      </p>
      <p class="para">
       También están disponibles varios <a href="#reference.pcre.pattern.modifiers" class="link">modificadores PCRE</a>.
      </p>
     </dd>
    
    
     <dt><code class="parameter">replacement</code></dt>
     <dd>
      <p class="para">
       La cadena o un array de cadenas para el reemplazo.
       Si este parámetro es una cadena y el parámetro <code class="parameter">pattern</code>
       es un array, todos los patrones serán reemplazados por esta cadena.
       Si los parámetros <code class="parameter">pattern</code> y
       <code class="parameter">replacement</code> son arrays, cada
       <code class="parameter">pattern</code> será reemplazado por su
       <code class="parameter">replacement</code> asociado.
       Si <code class="parameter">replacement</code> tiene menos elementos
       que <code class="parameter">pattern</code>, entonces una cadena vacía es
       utilizada para el resto de los valores.
      </p>
      <p class="para">
       <code class="parameter">replacement</code> puede contener referencias
       de la forma <code class="literal">\<span class="replaceable">n</span></code> o
       <code class="literal">$<span class="replaceable">n</span></code>.
       Esta última forma es recomendada. Estas referencias serán reemplazadas
       por el texto capturado por la <span class="replaceable">n</span>-ésima parentesis
       capturante del patrón. <span class="replaceable">n</span> puede tomar valores de
       0 a 99, y <code class="literal">\0</code> o <code class="literal">$0</code>, corresponden al texto que
       satisface el patrón completo. Los paréntesis abiertos son contados de izquierda a derecha (empezando por 1) para
       determinar el número de paréntesis capturante.
       Es de notar que en los <span class="type"><a href="#language.types.string" class="type string">string</a></span> literales los antislashs deben
       ser escapados.
      </p>
      <p class="para">
       Cuando se trabaja con un patrón de reemplazo donde una referencia hacia atrás
       es seguida directamente por un número (i.e.: colocar un número literal inmediatamente
       después de una referencia hacia atrás), no se puede usar la sintaxis clásica
       <code class="literal">\1</code> para la referencia hacia atrás. <code class="literal">\11</code>, por ejemplo,
       será confuso para la función <span class="function"><strong>preg_replace()</strong></span> en el sentido de que
       no sabrá si se desea la referencia hacia atrás <code class="literal">\1</code> seguida del número
       <code class="literal">1</code> o si se desea la referencia hacia atrás <code class="literal">\11</code>
       seguida de "nada". En este caso, la solución es usar la sintaxis <code class="literal">${1}1</code>.
       Esto creará una referencia hacia atrás aislada <code class="literal">$1</code>, seguida del número
       literal <code class="literal">1</code>.
      </p>
      <p class="para">
       Cuando se usa la opción obsoleta <code class="literal">e</code>, esta función
       escapa algunos caracteres (<code class="literal">'</code>, <code class="literal">"</code>,
       <code class="literal">\</code> y NULL) en la cadena que reemplaza las referencias hacia atrás.
       Este comportamiento se justifica para asegurar que no ocurra ningún error de sintaxis
       al usar las referencias hacia atrás con comillas simples y dobles (e.g. <code class="literal">'strlen(\'$1\')+strlen("$2")'</code>).
       Asegúrese de estar familiarizado con la <a href="#language.types.string" class="link">sintaxis
       de las cadenas</a> para saber exactamente a qué debe parecerse la cadena interpretada.
      </p>
     </dd>
    
    
     <dt><code class="parameter">subject</code></dt>
     <dd>
      <p class="para">
       La cadena o el array que contiene las cadenas a buscar y reemplazar.
      </p>
      <p class="para">
       Si <code class="parameter">subject</code> es un array, entonces la operación
       será aplicada a cada uno de los elementos del array, y el array será devuelto.
      </p>
      <p class="para">
       Si el array <code class="parameter">subject</code> es asociativo, entonces las claves
       serán preservadas en el valor devuelto.
      </p>
     </dd>
    
    
     <dt><code class="parameter">limit</code></dt>
     <dd>
      <p class="para">
       El número máximo de reemplazos para cada patrón en
       cada cadena <code class="parameter">subject</code>. Por omisión, vale
       <code class="literal">-1</code> (sin límite).
      </p>
     </dd>
    
    
     <dt><code class="parameter">count</code></dt>
     <dd>
      <p class="para">
       Si se proporciona, esta variable contendrá el número de reemplazos realizados.
      </p>
     </dd>
    
   </dl>
  
 </div>


 <div class="refsect1 returnvalues" id="refsect1-function.preg-replace-returnvalues">
  <h3 class="title">Valores devueltos</h3>
  <p class="para">
   <span class="function"><strong>preg_replace()</strong></span> devuelve un array si el parámetro
   <code class="parameter">subject</code> es un array, o una cadena en caso contrario.
  </p>
  <p class="para">
   Si se encuentran coincidencias, el nuevo
   <code class="parameter">subject</code> será devuelto, de lo contrario
   <code class="parameter">subject</code> será devuelto sin cambios, o <strong><code><a href="#constant.null">null</a></code></strong>
   si ocurre un error.
  </p>
 </div>


 <div class="refsect1 errors" id="refsect1-function.preg-replace-errors">
  <h3 class="title">Errores/Excepciones</h3>
  <p class="para">
   Utilizar la opción "\e" es un error; se emite una <strong><code><a href="#constant.e-warning">E_WARNING</a></code></strong>
   en este caso.
  </p>
  <p class="para">
Si el patrón regex pasado no se compila a una regex válida, se emite una <strong><code><a href="#constant.e-warning">E_WARNING</a></code></strong>.
</p>
 </div>


 <div class="refsect1 examples" id="refsect1-function.preg-replace-examples">
  <h3 class="title">Ejemplos</h3>
  <p class="para">
   </p><div class="example" id="example-5048">
    <p><strong>Ejemplo #1 Uso de referencias hacia atrás con literales numéricos</strong></p>
    <div class="example-contents">
<div class="annotation-interactive phpcode"><code><span style="color: #000000"><span style="color: #0000BB">&lt;?php<br>$string </span><span style="color: #007700">= </span><span style="color: #DD0000">'April 15, 2003'</span><span style="color: #007700">;<br></span><span style="color: #0000BB">$pattern </span><span style="color: #007700">= </span><span style="color: #DD0000">'/(\w+) (\d+), (\d+)/i'</span><span style="color: #007700">;<br></span><span style="color: #0000BB">$replacement </span><span style="color: #007700">= </span><span style="color: #DD0000">'${1}1,$3'</span><span style="color: #007700">;<br>echo </span><span style="color: #0000BB">preg_replace</span><span style="color: #007700">(</span><span style="color: #0000BB">$pattern</span><span style="color: #007700">, </span><span style="color: #0000BB">$replacement</span><span style="color: #007700">, </span><span style="color: #0000BB">$string</span><span style="color: #007700">);<br></span><span style="color: #0000BB">?&gt;</span></span></code></div>
    </div>

    <div class="example-contents"><p>El ejemplo anterior mostrará:</p></div>
    <div class="example-contents screen">
<div class="annotation-interactive examplescode"><pre class="examplescode">April1,2003</pre>
</div>
    </div>
   </div>
  
  <p class="para">
   </p><div class="example" id="example-5049">
    <p><strong>Ejemplo #2 Uso de arrays indexados con <span class="function"><strong>preg_replace()</strong></span></strong></p>
    <div class="example-contents">
<div class="annotation-interactive phpcode"><code><span style="color: #000000"><span style="color: #0000BB">&lt;?php<br>$string </span><span style="color: #007700">= </span><span style="color: #DD0000">'Le renard marron agile saute par dessus le chien paresseux.'</span><span style="color: #007700">;<br></span><span style="color: #0000BB">$patterns </span><span style="color: #007700">= array();<br></span><span style="color: #0000BB">$patterns</span><span style="color: #007700">[</span><span style="color: #0000BB">0</span><span style="color: #007700">] = </span><span style="color: #DD0000">'/agile/'</span><span style="color: #007700">;<br></span><span style="color: #0000BB">$patterns</span><span style="color: #007700">[</span><span style="color: #0000BB">1</span><span style="color: #007700">] = </span><span style="color: #DD0000">'/marron/'</span><span style="color: #007700">;<br></span><span style="color: #0000BB">$patterns</span><span style="color: #007700">[</span><span style="color: #0000BB">2</span><span style="color: #007700">] = </span><span style="color: #DD0000">'/renard/'</span><span style="color: #007700">;<br></span><span style="color: #0000BB">$replacements </span><span style="color: #007700">= array();<br></span><span style="color: #0000BB">$replacements</span><span style="color: #007700">[</span><span style="color: #0000BB">2</span><span style="color: #007700">] = </span><span style="color: #DD0000">'grizzly'</span><span style="color: #007700">;<br></span><span style="color: #0000BB">$replacements</span><span style="color: #007700">[</span><span style="color: #0000BB">1</span><span style="color: #007700">] = </span><span style="color: #DD0000">'brun'</span><span style="color: #007700">;<br></span><span style="color: #0000BB">$replacements</span><span style="color: #007700">[</span><span style="color: #0000BB">0</span><span style="color: #007700">] = </span><span style="color: #DD0000">'lent'</span><span style="color: #007700">;<br>echo </span><span style="color: #0000BB">preg_replace</span><span style="color: #007700">(</span><span style="color: #0000BB">$patterns</span><span style="color: #007700">, </span><span style="color: #0000BB">$replacements</span><span style="color: #007700">, </span><span style="color: #0000BB">$string</span><span style="color: #007700">);<br></span><span style="color: #0000BB">?&gt;</span></span></code></div>
    </div>

    <div class="example-contents"><p>El ejemplo anterior mostrará:</p></div>
    <div class="example-contents screen">
<div class="annotation-interactive examplescode"><pre class="examplescode">Le lent brun grizzly saute par dessus le chien paresseux.</pre>
</div>
    </div>
    <div class="example-contents"><p>
     Ordenando los patrones y los reemplazos, se debería obtener el resultado esperado.
    </p></div>
    <div class="example-contents">
<div class="annotation-interactive phpcode"><code><span style="color: #000000"><span style="color: #0000BB">&lt;?php<br>$string </span><span style="color: #007700">= </span><span style="color: #DD0000">'Le renard marron agile saute par dessus le chien paresseux.'</span><span style="color: #007700">;<br></span><span style="color: #0000BB">$patterns </span><span style="color: #007700">= array();<br></span><span style="color: #0000BB">$patterns</span><span style="color: #007700">[</span><span style="color: #0000BB">0</span><span style="color: #007700">] = </span><span style="color: #DD0000">'/agile/'</span><span style="color: #007700">;<br></span><span style="color: #0000BB">$patterns</span><span style="color: #007700">[</span><span style="color: #0000BB">1</span><span style="color: #007700">] = </span><span style="color: #DD0000">'/marron/'</span><span style="color: #007700">;<br></span><span style="color: #0000BB">$patterns</span><span style="color: #007700">[</span><span style="color: #0000BB">2</span><span style="color: #007700">] = </span><span style="color: #DD0000">'/renard/'</span><span style="color: #007700">;<br></span><span style="color: #0000BB">$replacements </span><span style="color: #007700">= array();<br></span><span style="color: #0000BB">$replacements</span><span style="color: #007700">[</span><span style="color: #0000BB">2</span><span style="color: #007700">] = </span><span style="color: #DD0000">'grizzly'</span><span style="color: #007700">;<br></span><span style="color: #0000BB">$replacements</span><span style="color: #007700">[</span><span style="color: #0000BB">1</span><span style="color: #007700">] = </span><span style="color: #DD0000">'brun'</span><span style="color: #007700">;<br></span><span style="color: #0000BB">$replacements</span><span style="color: #007700">[</span><span style="color: #0000BB">0</span><span style="color: #007700">] = </span><span style="color: #DD0000">'lent'</span><span style="color: #007700">;<br></span><span style="color: #0000BB">ksort</span><span style="color: #007700">(</span><span style="color: #0000BB">$patterns</span><span style="color: #007700">);<br></span><span style="color: #0000BB">ksort</span><span style="color: #007700">(</span><span style="color: #0000BB">$replacements</span><span style="color: #007700">);<br>echo </span><span style="color: #0000BB">preg_replace</span><span style="color: #007700">(</span><span style="color: #0000BB">$patterns</span><span style="color: #007700">, </span><span style="color: #0000BB">$replacements</span><span style="color: #007700">, </span><span style="color: #0000BB">$string</span><span style="color: #007700">);<br></span><span style="color: #0000BB">?&gt;</span></span></code></div>
    </div>

    <div class="example-contents"><p>El ejemplo anterior mostrará:</p></div>
    <div class="example-contents screen">
<div class="annotation-interactive examplescode"><pre class="examplescode">Le grizzly brun lent saute par dessus le chien paresseux.</pre>
</div>
    </div>
   </div>
  
  <p class="para">
   </p><div class="example" id="example-5050">
    <p><strong>Ejemplo #3 Reemplazo de múltiples valores simultáneamente</strong></p>
    <div class="example-contents">
<div class="annotation-interactive phpcode"><code><span style="color: #000000"><span style="color: #0000BB">&lt;?php<br>$patterns </span><span style="color: #007700">= array (</span><span style="color: #DD0000">'/(19|20)(\d{2})-(\d{1,2})-(\d{1,2})/'</span><span style="color: #007700">,<br>                   </span><span style="color: #DD0000">'/^\s*{(\w+)}\s*=/'</span><span style="color: #007700">);<br></span><span style="color: #0000BB">$replace </span><span style="color: #007700">= array (</span><span style="color: #DD0000">'\3/\4/\1\2'</span><span style="color: #007700">, </span><span style="color: #DD0000">'$\1 ='</span><span style="color: #007700">);<br>echo </span><span style="color: #0000BB">preg_replace</span><span style="color: #007700">(</span><span style="color: #0000BB">$patterns</span><span style="color: #007700">, </span><span style="color: #0000BB">$replace</span><span style="color: #007700">, </span><span style="color: #DD0000">'{startDate} = 1999-5-27'</span><span style="color: #007700">);<br></span><span style="color: #0000BB">?&gt;</span></span></code></div>
    </div>

    <div class="example-contents"><p>El ejemplo anterior mostrará:</p></div>
    <div class="example-contents screen">
<div class="annotation-interactive examplescode"><pre class="examplescode">$startDate = 5/27/1999</pre>
</div>
    </div>
   </div>
  
  <p class="para">
   </p><div class="example" id="example-5051">
    <p><strong>Ejemplo #4 Eliminación de espacios</strong></p>
    <div class="example-contents"><p>
     Este ejemplo elimina los espacios en exceso en una cadena.
    </p></div>
    <div class="example-contents">
<div class="annotation-interactive phpcode"><code><span style="color: #000000"><span style="color: #0000BB">&lt;?php<br>$str </span><span style="color: #007700">= </span><span style="color: #DD0000">'foo   o'</span><span style="color: #007700">;<br></span><span style="color: #0000BB">$str </span><span style="color: #007700">= </span><span style="color: #0000BB">preg_replace</span><span style="color: #007700">(</span><span style="color: #DD0000">'/\s\s+/'</span><span style="color: #007700">, </span><span style="color: #DD0000">' '</span><span style="color: #007700">, </span><span style="color: #0000BB">$str</span><span style="color: #007700">);<br></span><span style="color: #FF8000">// Mostrará 'foo o'<br></span><span style="color: #007700">echo </span><span style="color: #0000BB">$str</span><span style="color: #007700">;<br></span><span style="color: #0000BB">?&gt;</span></span></code></div>
    </div>

   </div>
  
  <p class="para">
   </p><div class="example" id="example-5052">
    <p><strong>Ejemplo #5 Uso del parámetro <code class="parameter">count</code></strong></p>
    <div class="example-contents">
<div class="annotation-interactive phpcode"><code><span style="color: #000000"><span style="color: #0000BB">&lt;?php<br>$count </span><span style="color: #007700">= </span><span style="color: #0000BB">0</span><span style="color: #007700">;<br><br>echo </span><span style="color: #0000BB">preg_replace</span><span style="color: #007700">(array(</span><span style="color: #DD0000">'/\d/'</span><span style="color: #007700">, </span><span style="color: #DD0000">'/\s/'</span><span style="color: #007700">), </span><span style="color: #DD0000">'*'</span><span style="color: #007700">, </span><span style="color: #DD0000">'xp 4 to'</span><span style="color: #007700">, -</span><span style="color: #0000BB">1 </span><span style="color: #007700">, </span><span style="color: #0000BB">$count</span><span style="color: #007700">);<br>echo </span><span style="color: #0000BB">$count</span><span style="color: #007700">; </span><span style="color: #FF8000">//3<br></span><span style="color: #0000BB">?&gt;</span></span></code></div>
    </div>

    <div class="example-contents"><p>El ejemplo anterior mostrará:</p></div>
    <div class="example-contents screen">
<div class="annotation-interactive examplescode"><pre class="examplescode">xp***to
3</pre>
</div>
    </div>
   </div>
  
 </div>


 <div class="refsect1 notes" id="refsect1-function.preg-replace-notes">
  <h3 class="title">Notas</h3>
  <blockquote class="note"><p><strong class="note">Nota</strong>: 
   </p><p class="para">
    Cuando se usan arrays con los parámetros
    <code class="parameter">pattern</code> y
    <code class="parameter">replacement</code>, las claves son tratadas
    en el orden en que aparecen en el array.
    Esto <em>no es necesariamente</em> lo mismo que
    el orden de los índices numéricos. Si se usan índices para
    identificar qué <code class="parameter">pattern</code> debe ser
    reemplazado por qué <code class="parameter">replacement</code>, se
    recomienda hacer un ordenamiento <span class="function"><a href="#function.ksort" class="function">ksort()</a></span> en cada
    array antes de llamar a <span class="function"><strong>preg_replace()</strong></span>.
   </p>
  </blockquote>
  <blockquote class="note"><p><strong class="note">Nota</strong>: 
   </p><p class="para">
    Cuando <code class="parameter">pattern</code> y <code class="parameter">replacement</code>
    son arrays, las reglas de coincidencia funcionarán de
    manera secuencial. Es decir, la segunda pareja
    <code class="parameter">pattern</code>/<code class="parameter">replacement</code>
    operará sobre la cadena de caracteres que resulta de la primera pareja
    <code class="parameter">pattern</code>/<code class="parameter">replacement</code>,
    y no sobre la cadena original. Si se desea simular reemplazos
    funcionando en paralelo, como el intercambio de dos valores, reemplace un
    patrón por un sustituto intermedio, luego en una pareja posterior,
    reemplace este marcador intermedio por el reemplazo deseado.
   </p>
   <div class="informalexample">
    <div class="example-contents">
<div class="annotation-interactive phpcode"><code><span style="color: #000000"><span style="color: #0000BB">&lt;?php<br>$p </span><span style="color: #007700">= array(</span><span style="color: #DD0000">'/a/'</span><span style="color: #007700">, </span><span style="color: #DD0000">'/b/'</span><span style="color: #007700">, </span><span style="color: #DD0000">'/c/'</span><span style="color: #007700">);<br></span><span style="color: #0000BB">$r </span><span style="color: #007700">= array(</span><span style="color: #DD0000">'b'</span><span style="color: #007700">, </span><span style="color: #DD0000">'c'</span><span style="color: #007700">, </span><span style="color: #DD0000">'d'</span><span style="color: #007700">);<br></span><span style="color: #0000BB">print_r</span><span style="color: #007700">(</span><span style="color: #0000BB">preg_replace</span><span style="color: #007700">(</span><span style="color: #0000BB">$p</span><span style="color: #007700">, </span><span style="color: #0000BB">$r</span><span style="color: #007700">, </span><span style="color: #DD0000">'a'</span><span style="color: #007700">));<br></span><span style="color: #FF8000">// imprime d<br></span><span style="color: #0000BB">?&gt;</span></span></code></div>
    </div>

   </div>
  </blockquote>
 </div>


 <div class="refsect1 seealso" id="refsect1-function.preg-replace-seealso">
  <h3 class="title">Ver también</h3>
  <p class="para">
   </p><ul class="simplelist">
    <li><a href="#pcre.pattern" class="link">Patrones PCRE</a></li>
    <li><span class="function"><a href="#function.preg-quote" class="function" rel="rdfs-seeAlso">preg_quote()</a> - Protección de caracteres especiales de expresiones regulares</span></li>
    <li><span class="function"><a href="#function.preg-filter" class="function" rel="rdfs-seeAlso">preg_filter()</a> - Búsqueda y reemplazo con una expresión regular</span></li>
    <li><span class="function"><a href="#function.preg-match" class="function" rel="rdfs-seeAlso">preg_match()</a> - Realiza una búsqueda de coincidencia con una expresión regular estándar</span></li>
    <li><span class="function"><a href="#function.preg-replace-callback" class="function" rel="rdfs-seeAlso">preg_replace_callback()</a> - Buscar y reemplazar mediante expresión regular estándar utilizando una función de retrollamada</span></li>
    <li><span class="function"><a href="#function.preg-split" class="function" rel="rdfs-seeAlso">preg_split()</a> - Divide una cadena mediante expresión regular</span></li>
    <li><span class="function"><a href="#function.preg-last-error" class="function" rel="rdfs-seeAlso">preg_last_error()</a> - Devuelve el código de error de la última expresión PCRE ejecutada</span></li>
    <li><span class="function"><a href="#function.str-replace" class="function" rel="rdfs-seeAlso">str_replace()</a> - Reemplaza todas las ocurrencias en una string</span></li>
   </ul>
  
 </div>

</div>
<hr>






<div id="function.preg-replace-callback" class="refentry"><hr>
 <div class="refnamediv">
  <h1 class="refname">preg_replace_callback</h1>
  <p class="verinfo">(PHP 4 &gt;= 4.0.5, PHP 5, PHP 7, PHP 8)</p><p class="refpurpose"><span class="refname">preg_replace_callback</span> — <span class="dc-title">Buscar y reemplazar mediante expresión regular estándar utilizando una función de retrollamada</span></p>

 </div>

 <div class="refsect1 description" id="refsect1-function.preg-replace-callback-description">
  <h3 class="title">Descripción</h3>
  <div class="methodsynopsis dc-description">
   <span class="methodname"><strong>preg_replace_callback</strong></span>(<br>    <span class="methodparam"><span class="type"><span class="type"><a href="#language.types.string" class="type string">string</a></span>|<span class="type"><a href="#language.types.array" class="type array">array</a></span></span> <code class="parameter">$pattern</code></span>,<br>    <span class="methodparam"><span class="type"><a href="#language.types.callable" class="type callable">callable</a></span> <code class="parameter">$callback</code></span>,<br>    <span class="methodparam"><span class="type"><span class="type"><a href="#language.types.string" class="type string">string</a></span>|<span class="type"><a href="#language.types.array" class="type array">array</a></span></span> <code class="parameter">$subject</code></span>,<br>    <span class="methodparam"><span class="type"><a href="#language.types.integer" class="type int">int</a></span> <code class="parameter">$limit</code><span class="initializer"> = -1</span></span>,<br>    <span class="methodparam"><span class="type"><a href="#language.types.integer" class="type int">int</a></span> <code class="parameter reference">&amp;$count</code><span class="initializer"> = <strong><code><a href="#constant.null">null</a></code></strong></span></span>,<br>    <span class="methodparam"><span class="type"><a href="#language.types.integer" class="type int">int</a></span> <code class="parameter">$flags</code><span class="initializer"> = 0</span></span><br>): <span class="type"><span class="type"><a href="#language.types.string" class="type string">string</a></span>|<span class="type"><a href="#language.types.array" class="type array">array</a></span>|<span class="type"><a href="#language.types.null" class="type null">null</a></span></span></div>

  <p class="para rdfs-comment">
   El comportamiento de <span class="function"><strong>preg_replace_callback()</strong></span> es casi
   idéntico al de <span class="function"><a href="#function.preg-replace" class="function">preg_replace()</a></span>, con la excepción de que
   en lugar del argumento <code class="parameter">replacement</code>, se debe
   especificar una función de retrollamada <code class="parameter">callback</code>
   que será llamada con los elementos encontrados como argumentos.
  </p>
 </div>


 <div class="refsect1 parameters" id="refsect1-function.preg-replace-callback-parameters">
  <h3 class="title">Parámetros</h3>
  <p class="para">
   </p><dl>
    
     <dt><code class="parameter">pattern</code></dt>
     <dd>
      <p class="para">
       El patrón a buscar. Puede ser un <span class="type"><a href="#language.types.string" class="type string">string</a></span> o un array que contenga
       cadenas.
      </p>
     </dd>
    
    
     <dt><code class="parameter">callback</code></dt>
     <dd>
      <p class="para">
       La función de retrollamada que recibirá el array de elementos
       encontrados en la cadena <code class="parameter">subject</code>.
       La función de retrollamada debe devolver la cadena de
       reemplazo. Esta es la firma de la función de retrollamada:
      </p>
      <p class="para">
       </p><div class="methodsynopsis dc-description">
        <span class="methodname"><span class="replaceable">handler</span></span>(<span class="methodparam"><span class="type"><a href="#language.types.array" class="type array">array</a></span> <code class="parameter">$matches</code></span>): <span class="type"><a href="#language.types.string" class="type string">string</a></span></div>

      
      <p class="para">
       Con frecuencia, la función <code class="parameter">callback</code> se utiliza
       con <span class="function"><strong>preg_replace_callback()</strong></span> en un solo lugar.
       En este caso, puede simplemente utilizar una
       <a href="#functions.anonymous" class="link">función anónima</a>
       para declarar una función de retrollamada para
       <span class="function"><strong>preg_replace_callback()</strong></span>.
       Al hacer esto, se concentran todas las rutinas relacionadas con
       el reemplazo en un solo lugar, y no se contamina el espacio de nombres de funciones con funciones de un solo uso.
      </p>
      <p class="para">
       </p><div class="example" id="example-5053">
        <p><strong>Ejemplo #1 <span class="function"><strong>preg_replace_callback()</strong></span> y
        función anónima</strong></p>
        <div class="example-contents">
<div class="annotation-non-interactive phpcode"><code><span style="color: #000000"><span style="color: #0000BB">&lt;?php<br></span><span style="color: #FF8000">// Un filtro de línea de comandos Unix para convertir la primera letra<br>// de los párrafos (que comienzan con "&lt;p&gt;") a minúscula<br><br></span><span style="color: #0000BB">$fp </span><span style="color: #007700">= </span><span style="color: #0000BB">fopen</span><span style="color: #007700">(</span><span style="color: #DD0000">"php://stdin"</span><span style="color: #007700">, </span><span style="color: #DD0000">"r"</span><span style="color: #007700">) or die(</span><span style="color: #DD0000">"No se puede leer la línea de comandos"</span><span style="color: #007700">);<br>while (!</span><span style="color: #0000BB">feof</span><span style="color: #007700">(</span><span style="color: #0000BB">$fp</span><span style="color: #007700">)) {<br>    </span><span style="color: #0000BB">$line </span><span style="color: #007700">= </span><span style="color: #0000BB">fgets</span><span style="color: #007700">(</span><span style="color: #0000BB">$fp</span><span style="color: #007700">);<br>    </span><span style="color: #0000BB">$line </span><span style="color: #007700">= </span><span style="color: #0000BB">preg_replace_callback</span><span style="color: #007700">(<br>        </span><span style="color: #DD0000">'|&lt;p&gt;\s*\w|'</span><span style="color: #007700">,<br>        function (</span><span style="color: #0000BB">$matches</span><span style="color: #007700">) {<br>            return </span><span style="color: #0000BB">strtolower</span><span style="color: #007700">(</span><span style="color: #0000BB">$matches</span><span style="color: #007700">[</span><span style="color: #0000BB">0</span><span style="color: #007700">]);<br>        },<br>        </span><span style="color: #0000BB">$line<br>    </span><span style="color: #007700">);<br>    echo </span><span style="color: #0000BB">$line</span><span style="color: #007700">;<br>}<br></span><span style="color: #0000BB">fclose</span><span style="color: #007700">(</span><span style="color: #0000BB">$fp</span><span style="color: #007700">);<br></span><span style="color: #0000BB">?&gt;</span></span></code></div>
        </div>

       </div>
      
     </dd>
    
    
     <dt><code class="parameter">subject</code></dt>
     <dd>
      <p class="para">
       La cadena o el array de cadenas a buscar y reemplazar.
      </p>
     </dd>
    
    
     <dt><code class="parameter">limit</code></dt>
     <dd>
      <p class="para">
       El número máximo de reemplazos para cada patrón
       en cada cadena <code class="parameter">subject</code>.
       Por omisión, vale <code class="literal">-1</code> (sin límite).
      </p>
     </dd>
    
    
     <dt><code class="parameter">count</code></dt>
     <dd>
      <p class="para">
       Si se proporciona, esta variable será rellenada con el número de reemplazos realizados.
      </p>
     </dd>
    
    
     <dt><code class="parameter">flags</code></dt>
     <dd>
      <p class="para">
       <code class="parameter">flags</code> puede ser una combinación de los indicadores
       <strong><code><a href="#constant.preg-offset-capture">PREG_OFFSET_CAPTURE</a></code></strong> y
       <strong><code><a href="#constant.preg-unmatched-as-null">PREG_UNMATCHED_AS_NULL</a></code></strong>, que influyen en el formato
       del array de coincidencias.
       Consulte la descripción de <span class="function"><a href="#function.preg-match" class="function">preg_match()</a></span> para más detalles.
      </p>
     </dd>
    
   </dl>
  
 </div>


 <div class="refsect1 returnvalues" id="refsect1-function.preg-replace-callback-returnvalues">
  <h3 class="title">Valores devueltos</h3>
  <p class="para">
   <span class="function"><strong>preg_replace_callback()</strong></span> devuelve un array si el argumento
   <code class="parameter">subject</code> es un <span class="type"><a href="#language.types.array" class="type array">array</a></span>, o, de lo contrario, un <span class="type"><a href="#language.types.string" class="type string">string</a></span>.
   Si ocurre un error, el valor devuelto será <strong><code><a href="#constant.null">null</a></code></strong>.
  </p>
  <p class="para">
   Si se encuentran coincidencias, se devuelve el nuevo sujeto, de lo contrario
   <code class="parameter">subject</code> se devuelve sin cambios.
  </p>
 </div>


 <div class="refsect1 errors" id="refsect1-function.preg-replace-callback-errors">
  <h3 class="title">Errores/Excepciones</h3>
  <p class="para">
Si el patrón regex pasado no se compila a una regex válida, se emite una <strong><code><a href="#constant.e-warning">E_WARNING</a></code></strong>.
</p>
 </div>


 <div class="refsect1 changelog" id="refsect1-function.preg-replace-callback-changelog">
  <h3 class="title">Historial de cambios</h3>
  <p class="para">
   </p><table class="doctable informaltable">
    
     <thead>
      <tr>
       <th>Versión</th>
       <th>Descripción</th>
      </tr>

     </thead>

     <tbody class="tbody">
      <tr>
       <td>7.4.0</td>
       <td>
        Se añadió el argumento <code class="parameter">flags</code>.
       </td>
      </tr>

     </tbody>
    
   </table>

  
 </div>


 <div class="refsect1 examples" id="refsect1-function.preg-replace-callback-examples">
  <h3 class="title">Ejemplos</h3>
  <p class="para">
   </p><div class="example" id="example-5054">
    <p><strong>Ejemplo #2 Ejemplo con <span class="function"><strong>preg_replace_callback()</strong></span></strong></p>
    <div class="example-contents">
<div class="annotation-interactive phpcode"><code><span style="color: #000000"><span style="color: #0000BB">&lt;?php<br></span><span style="color: #FF8000">// Este texto era cierto en 2002<br>// queremos actualizarlo para 2003<br></span><span style="color: #0000BB">$text </span><span style="color: #007700">= </span><span style="color: #DD0000">"El primer abril es el 04/01/2002\n"</span><span style="color: #007700">;<br></span><span style="color: #0000BB">$text</span><span style="color: #007700">.= </span><span style="color: #DD0000">"La última navidad fue el 12/24/2001\n"</span><span style="color: #007700">;<br><br></span><span style="color: #FF8000">// Función de retrollamada<br></span><span style="color: #007700">function </span><span style="color: #0000BB">next_year</span><span style="color: #007700">(</span><span style="color: #0000BB">$matches</span><span style="color: #007700">)<br>{<br>  </span><span style="color: #FF8000">// como de costumbre: $matches[0] representa el valor total<br>  // $matches[1] representa el primer paréntesis capturante<br>  </span><span style="color: #007700">return </span><span style="color: #0000BB">$matches</span><span style="color: #007700">[</span><span style="color: #0000BB">1</span><span style="color: #007700">].(</span><span style="color: #0000BB">$matches</span><span style="color: #007700">[</span><span style="color: #0000BB">2</span><span style="color: #007700">]+</span><span style="color: #0000BB">1</span><span style="color: #007700">);<br>}<br>echo </span><span style="color: #0000BB">preg_replace_callback</span><span style="color: #007700">(<br>            </span><span style="color: #DD0000">"|(\d{2}/\d{2}/)(\d{4})|"</span><span style="color: #007700">,<br>            </span><span style="color: #DD0000">"next_year"</span><span style="color: #007700">,<br>            </span><span style="color: #0000BB">$text</span><span style="color: #007700">);<br><br></span><span style="color: #0000BB">?&gt;</span></span></code></div>
    </div>

    <div class="example-contents"><p>El ejemplo anterior mostrará:</p></div>
    <div class="example-contents screen">
<div class="annotation-interactive examplescode"><pre class="examplescode">El primer abril es el 04/01/2003
La última navidad fue el 12/24/2002</pre>
</div>
    </div>
   </div>
  
  <p class="para">
   </p><div class="example" id="example-5055">
    <p><strong>Ejemplo #3 Ejemplo con <span class="function"><strong>preg_replace_callback()</strong></span> utilizando una estructura recursiva
     para manejar BB code</strong></p>
    <div class="example-contents">
<div class="annotation-interactive phpcode"><code><span style="color: #000000"><span style="color: #0000BB">&lt;?php<br>$input </span><span style="color: #007700">= </span><span style="color: #DD0000">"plain [indent] deep [indent] deeper [/indent] deep [/indent] plain"</span><span style="color: #007700">;<br><br>function </span><span style="color: #0000BB">parseTagsRecursive</span><span style="color: #007700">(</span><span style="color: #0000BB">$input</span><span style="color: #007700">)<br>{<br><br>    </span><span style="color: #0000BB">$regex </span><span style="color: #007700">= </span><span style="color: #DD0000">'#\[indent]((?:[^[]|\[(?!/?indent])|(?R))+)\[/indent]#'</span><span style="color: #007700">;<br><br>    if (</span><span style="color: #0000BB">is_array</span><span style="color: #007700">(</span><span style="color: #0000BB">$input</span><span style="color: #007700">)) {<br>        </span><span style="color: #0000BB">$input </span><span style="color: #007700">= </span><span style="color: #DD0000">'&lt;div style="margin-left: 10px"&gt;'</span><span style="color: #007700">.</span><span style="color: #0000BB">$input</span><span style="color: #007700">[</span><span style="color: #0000BB">1</span><span style="color: #007700">].</span><span style="color: #DD0000">'&lt;/div&gt;'</span><span style="color: #007700">;<br>    }<br><br>    return </span><span style="color: #0000BB">preg_replace_callback</span><span style="color: #007700">(</span><span style="color: #0000BB">$regex</span><span style="color: #007700">, </span><span style="color: #DD0000">'parseTagsRecursive'</span><span style="color: #007700">, </span><span style="color: #0000BB">$input</span><span style="color: #007700">);<br>}<br><br></span><span style="color: #0000BB">$output </span><span style="color: #007700">= </span><span style="color: #0000BB">parseTagsRecursive</span><span style="color: #007700">(</span><span style="color: #0000BB">$input</span><span style="color: #007700">);<br><br>echo </span><span style="color: #0000BB">$output</span><span style="color: #007700">;<br></span><span style="color: #0000BB">?&gt;</span></span></code></div>
    </div>

   </div>
  
 </div>


 <div class="refsect1 seealso" id="refsect1-function.preg-replace-callback-seealso">
  <h3 class="title">Ver también</h3>
  <p class="para">
   </p><ul class="simplelist">
    <li><a href="#pcre.pattern" class="link">Patrones PCRE</a></li>
    <li><span class="function"><a href="#function.preg-replace-callback-array" class="function" rel="rdfs-seeAlso">preg_replace_callback_array()</a> - Realiza una búsqueda de coincidencia con una expresión regular y reemplaza mediante una función de devolución de llamada</span></li>
    <li><span class="function"><a href="#function.preg-quote" class="function" rel="rdfs-seeAlso">preg_quote()</a> - Protección de caracteres especiales de expresiones regulares</span></li>
    <li><span class="function"><a href="#function.preg-replace" class="function" rel="rdfs-seeAlso">preg_replace()</a> - Buscar y reemplazar mediante expresión regular estándar</span></li>
    <li><span class="function"><a href="#function.preg-last-error" class="function" rel="rdfs-seeAlso">preg_last_error()</a> - Devuelve el código de error de la última expresión PCRE ejecutada</span></li>
    <li><a href="#functions.anonymous" class="link">Las funciones anónimas</a></li>
   </ul>
  
 </div>


</div>
<hr>







<div id="function.preg-replace-callback-array" class="refentry"><hr>
 <div class="refnamediv">
  <h1 class="refname">preg_replace_callback_array</h1>
  <p class="verinfo">(PHP 7, PHP 8)</p><p class="refpurpose"><span class="refname">preg_replace_callback_array</span> — <span class="dc-title">Realiza una búsqueda de coincidencia con una expresión regular y reemplaza mediante una función de devolución de llamada</span></p>

 </div>

 <div class="refsect1 description" id="refsect1-function.preg-replace-callback-array-description">
  <h3 class="title">Descripción</h3>
  <div class="methodsynopsis dc-description">
   <span class="methodname"><strong>preg_replace_callback_array</strong></span>(<br>    <span class="methodparam"><span class="type"><a href="#language.types.array" class="type array">array</a></span> <code class="parameter">$pattern</code></span>,<br>    <span class="methodparam"><span class="type"><span class="type"><a href="#language.types.string" class="type string">string</a></span>|<span class="type"><a href="#language.types.array" class="type array">array</a></span></span> <code class="parameter">$subject</code></span>,<br>    <span class="methodparam"><span class="type"><a href="#language.types.integer" class="type int">int</a></span> <code class="parameter">$limit</code><span class="initializer"> = -1</span></span>,<br>    <span class="methodparam"><span class="type"><a href="#language.types.integer" class="type int">int</a></span> <code class="parameter reference">&amp;$count</code><span class="initializer"> = <strong><code><a href="#constant.null">null</a></code></strong></span></span>,<br>    <span class="methodparam"><span class="type"><a href="#language.types.integer" class="type int">int</a></span> <code class="parameter">$flags</code><span class="initializer"> = 0</span></span><br>): <span class="type"><span class="type"><a href="#language.types.string" class="type string">string</a></span>|<span class="type"><a href="#language.types.array" class="type array">array</a></span>|<span class="type"><a href="#language.types.null" class="type null">null</a></span></span></div>

  <p class="para rdfs-comment">
   El comportamiento de esta función es similar a
   <span class="function"><a href="#function.preg-replace-callback" class="function">preg_replace_callback()</a></span>, con la excepción de que las funciones de devolución de llamada
   se ejecutan para cada patrón.
  </p>
 </div>


 <div class="refsect1 parameters" id="refsect1-function.preg-replace-callback-array-parameters">
  <h3 class="title">Parámetros</h3>
  <p class="para">
   </p><dl>
    
     <dt><code class="parameter">pattern</code></dt>
     <dd>
      <p class="para">
       Un array asociativo que establece una relación entre los patrones (claves)
       y las funciones de devolución de llamada <span class="type"><a href="#language.types.callable" class="type callable">callable</a></span> (valores).
      </p>
     </dd>
    
    
     <dt><code class="parameter">subject</code></dt>
     <dd>
      <p class="para">
       La <span class="type"><a href="#language.types.string" class="type string">string</a></span> o <span class="type"><a href="#language.types.array" class="type array">array</a></span> que contiene los <span class="type"><a href="#language.types.string" class="type string">string</a></span> a buscar y reemplazar.
      </p>
     </dd>
    
    
     <dt><code class="parameter">limit</code></dt>
     <dd>
      <p class="para">
       El número máximo de reemplazos para cada patrón en cada
       <span class="type"><a href="#language.types.string" class="type string">string</a></span> <code class="parameter">subject</code>. Por omisión
       <code class="literal">-1</code> (sin límite).
      </p>
     </dd>
    
    
     <dt><code class="parameter">count</code></dt>
     <dd>
      <p class="para">
       Si se proporciona, esta variable será rellenada con el número de
       reemplazos realizados.
      </p>
     </dd>
    
    
     <dt><code class="parameter">flags</code></dt>
     <dd>
      <p class="para">
       <code class="parameter">flags</code> puede ser una combinación de los indicadores
       <strong><code><a href="#constant.preg-offset-capture">PREG_OFFSET_CAPTURE</a></code></strong> y
       <strong><code><a href="#constant.preg-unmatched-as-null">PREG_UNMATCHED_AS_NULL</a></code></strong>, que influyen en el formato
       del array de coincidencias.
       Ver la descripción de <span class="function"><a href="#function.preg-match" class="function">preg_match()</a></span> para más detalles.
      </p>
     </dd>
    
   </dl>
  
 </div>


 <div class="refsect1 returnvalues" id="refsect1-function.preg-replace-callback-array-returnvalues">
  <h3 class="title">Valores devueltos</h3>
  <p class="para">
   <span class="function"><strong>preg_replace_callback_array()</strong></span> devuelve un array si
   el parámetro <code class="parameter">subject</code> es un array, o de lo contrario
   una <span class="type"><a href="#language.types.string" class="type string">string</a></span>. En caso de error, el valor devuelto es <strong><code><a href="#constant.null">null</a></code></strong>.
  </p>
  <p class="para">
   Si se encuentran coincidencias, el nuevo sujeto será devuelto, de lo contrario
   <code class="parameter">subject</code> será devuelto sin cambios.</p>
 </div>


 <div class="refsect1 errors" id="refsect1-function.preg-replace-callback-array-errors">
  <h3 class="title">Errores/Excepciones</h3>
  <p class="para">
Si el patrón regex pasado no se compila a una regex válida, se emite una <strong><code><a href="#constant.e-warning">E_WARNING</a></code></strong>.
</p>
 </div>


 <div class="refsect1 changelog" id="refsect1-function.preg-replace-callback-array-changelog">
  <h3 class="title">Historial de cambios</h3>
  <p class="para">
   </p><table class="doctable informaltable">
    
     <thead>
      <tr>
       <th>Versión</th>
       <th>Descripción</th>
      </tr>

     </thead>

     <tbody class="tbody">
      <tr>
       <td>7.4.0</td>
       <td>
        El parámetro <code class="parameter">flags</code> ha sido añadido.
       </td>
      </tr>

     </tbody>
    
   </table>

  
 </div>


 <div class="refsect1 examples" id="refsect1-function.preg-replace-callback-array-examples">
  <h3 class="title">Ejemplos</h3>
  <p class="para">
   </p><div class="example" id="example-5056">
    <p><strong>Ejemplo #1 Ejemplo de <span class="function"><strong>preg_replace_callback_array()</strong></span></strong></p>
    <div class="example-contents">
<div class="annotation-interactive phpcode"><code><span style="color: #000000"><span style="color: #0000BB">&lt;?php<br>$subject </span><span style="color: #007700">= </span><span style="color: #DD0000">'Aaaaaa Bbb'</span><span style="color: #007700">;<br><br></span><span style="color: #0000BB">preg_replace_callback_array</span><span style="color: #007700">(<br>    [<br>        </span><span style="color: #DD0000">'~[a]+~i' </span><span style="color: #007700">=&gt; function (</span><span style="color: #0000BB">$match</span><span style="color: #007700">) {<br>            echo </span><span style="color: #0000BB">strlen</span><span style="color: #007700">(</span><span style="color: #0000BB">$match</span><span style="color: #007700">[</span><span style="color: #0000BB">0</span><span style="color: #007700">]), </span><span style="color: #DD0000">' coincidencias de "a" encontradas'</span><span style="color: #007700">, </span><span style="color: #0000BB">PHP_EOL</span><span style="color: #007700">;<br>        },<br>        </span><span style="color: #DD0000">'~[b]+~i' </span><span style="color: #007700">=&gt; function (</span><span style="color: #0000BB">$match</span><span style="color: #007700">) {<br>            echo </span><span style="color: #0000BB">strlen</span><span style="color: #007700">(</span><span style="color: #0000BB">$match</span><span style="color: #007700">[</span><span style="color: #0000BB">0</span><span style="color: #007700">]), </span><span style="color: #DD0000">' coincidencias de "b" encontradas'</span><span style="color: #007700">, </span><span style="color: #0000BB">PHP_EOL</span><span style="color: #007700">;<br>        }<br>    ],<br>    </span><span style="color: #0000BB">$subject<br></span><span style="color: #007700">);<br></span><span style="color: #0000BB">?&gt;</span></span></code></div>
    </div>

    <div class="example-contents"><p>El ejemplo anterior mostrará:</p></div>
    <div class="example-contents screen">
<div class="annotation-interactive examplescode"><pre class="examplescode">6 coincidencias de "a" encontradas
3 coincidencias de "b" encontradas</pre>
</div>
    </div>
   </div>
  
 </div>


 <div class="refsect1 seealso" id="refsect1-function.preg-replace-callback-array-seealso">
  <h3 class="title">Ver también</h3>
  <p class="para">
   </p><ul class="simplelist">
    <li><a href="#pcre.pattern" class="link">Patrones PCRE</a></li>
    <li><span class="function"><a href="#function.preg-replace-callback" class="function" rel="rdfs-seeAlso">preg_replace_callback()</a> - Buscar y reemplazar mediante expresión regular estándar utilizando una función de retrollamada</span></li>
    <li><span class="function"><a href="#function.preg-quote" class="function" rel="rdfs-seeAlso">preg_quote()</a> - Protección de caracteres especiales de expresiones regulares</span></li>
    <li><span class="function"><a href="#function.preg-replace" class="function" rel="rdfs-seeAlso">preg_replace()</a> - Buscar y reemplazar mediante expresión regular estándar</span></li>
    <li><span class="function"><a href="#function.preg-last-error" class="function" rel="rdfs-seeAlso">preg_last_error()</a> - Devuelve el código de error de la última expresión PCRE ejecutada</span></li>
    <li><a href="#functions.anonymous" class="link">Funciones anónimas</a></li>
   </ul>
  
 </div>


</div>
<hr>







<div id="function.preg-split" class="refentry"><hr>
 <div class="refnamediv">
  <h1 class="refname">preg_split</h1>
  <p class="verinfo">(PHP 4, PHP 5, PHP 7, PHP 8)</p><p class="refpurpose"><span class="refname">preg_split</span> — <span class="dc-title">Divide una cadena mediante expresión regular</span></p>

 </div>

 <div class="refsect1 description" id="refsect1-function.preg-split-description">
  <h3 class="title">Descripción</h3>
  <div class="methodsynopsis dc-description">
   <span class="methodname"><strong>preg_split</strong></span>(<br>    <span class="methodparam"><span class="type"><a href="#language.types.string" class="type string">string</a></span> <code class="parameter">$pattern</code></span>,<br>    <span class="methodparam"><span class="type"><a href="#language.types.string" class="type string">string</a></span> <code class="parameter">$subject</code></span>,<br>    <span class="methodparam"><span class="type"><a href="#language.types.integer" class="type int">int</a></span> <code class="parameter">$limit</code><span class="initializer"> = -1</span></span>,<br>    <span class="methodparam"><span class="type"><a href="#language.types.integer" class="type int">int</a></span> <code class="parameter">$flags</code><span class="initializer"> = 0</span></span><br>): <span class="type"><span class="type"><a href="#language.types.array" class="type array">array</a></span>|<span class="type"><a href="#language.types.singleton" class="type false">false</a></span></span></div>

  <p class="para rdfs-comment">
   Divide una cadena mediante expresión regular.
  </p>
 </div>


 <div class="refsect1 parameters" id="refsect1-function.preg-split-parameters">
  <h3 class="title">Parámetros</h3>
  <p class="para">
   </p><dl>
    
     <dt><code class="parameter">pattern</code></dt>
     <dd>
      <p class="para">
       El patrón a buscar, en forma de <span class="type"><a href="#language.types.string" class="type string">string</a></span>.
      </p>
     </dd>
    
    
     <dt><code class="parameter">subject</code></dt>
     <dd>
      <p class="para">
       La cadena de entrada.
      </p>
     </dd>
    
    
     <dt><code class="parameter">limit</code></dt>
     <dd>
      <p class="para">
       Si <code class="parameter">limit</code> está especificado, entonces solo se devuelven
       las <code class="parameter">limit</code> primeras sub-caenas con el resto de la cadena
       colocado en la última sub-caena.
       Un <code class="parameter">limit</code> de -1 o 0 significa "sin límite".
      </p>
     </dd>
    
    
     <dt><code class="parameter">flags</code></dt>
     <dd>
      <p class="para">
       <code class="parameter">flags</code> puede ser la combinación de las
       siguientes opciones (combinadas con el operador <code class="literal">|</code>):
       </p><dl>
        
         <dt><strong><code><a href="#constant.preg-split-no-empty">PREG_SPLIT_NO_EMPTY</a></code></strong></dt>
         <dd>
          <span class="simpara">
          Si esta opción está activada, solo se devuelven las sub-caenas no vacías
          por <span class="function"><strong>preg_split()</strong></span>.
          </span>
         </dd>
        
        
         <dt><strong><code><a href="#constant.preg-split-delim-capture">PREG_SPLIT_DELIM_CAPTURE</a></code></strong></dt>
         <dd>
          <span class="simpara">
          Si esta opción está activada, las expresiones entre paréntesis entre
          los delimitadores de patrones también serán capturadas y devueltas.
          </span>
         </dd>
        
        
         <dt><strong><code><a href="#constant.preg-split-offset-capture">PREG_SPLIT_OFFSET_CAPTURE</a></code></strong></dt>
         <dd>
          <p class="para">
           Si esta opción está activada, para cada resultado, su posición será devuelta.
           Tenga en cuenta que esto cambia el valor devuelto a un array donde cada elemento es un
           array compuesto por la cadena encontrada en la posición <code class="literal">0</code>
           y la posición de la cadena en <code class="parameter">subject</code> en
           la posición <code class="literal">1</code>.
          </p>
         </dd>
        
       </dl>
      
     </dd>
    
   </dl>
  
 </div>


 <div class="refsect1 returnvalues" id="refsect1-function.preg-split-returnvalues">
  <h3 class="title">Valores devueltos</h3>
  <p class="para">
   Devuelve un array que contiene las sub-caenas de <code class="parameter">subject</code>,
   separadas por las cadenas que coinciden con <code class="parameter">pattern</code>,  o <strong><code><a href="#constant.false">false</a></code></strong> si ocurre un error.
  </p>
 </div>


 <div class="refsect1 errors" id="refsect1-function.preg-split-errors">
  <h3 class="title">Errores/Excepciones</h3>
  <p class="para">
Si el patrón regex pasado no se compila a una regex válida, se emite una <strong><code><a href="#constant.e-warning">E_WARNING</a></code></strong>.
</p>
 </div>


 <div class="refsect1 examples" id="refsect1-function.preg-split-examples">
  <h3 class="title">Ejemplos</h3>
  <p class="para">
   </p><div class="example" id="example-5057">
    <p><strong>Ejemplo #1 Ejemplo con <span class="function"><strong>preg_split()</strong></span>: División de una cadena de búsqueda</strong></p>
    <div class="example-contents">
<div class="annotation-interactive phpcode"><code><span style="color: #000000"><span style="color: #0000BB">&lt;?php<br></span><span style="color: #FF8000">// divide la frase mediante comas y espacios<br>// lo que incluye los " ", \r, \t, \n y \f<br></span><span style="color: #0000BB">$keywords </span><span style="color: #007700">= </span><span style="color: #0000BB">preg_split</span><span style="color: #007700">(</span><span style="color: #DD0000">"/[\s,]+/"</span><span style="color: #007700">, </span><span style="color: #DD0000">"lenguaje de marcado, programación"</span><span style="color: #007700">);<br></span><span style="color: #0000BB">print_r</span><span style="color: #007700">(</span><span style="color: #0000BB">$keywords</span><span style="color: #007700">);<br></span><span style="color: #0000BB">?&gt;</span></span></code></div>
    </div>

    <div class="example-contents"><p>El ejemplo anterior mostrará:</p></div>
    <div class="example-contents screen">
<div class="annotation-interactive examplescode"><pre class="examplescode">Array
(
    [0] =&gt; lenguaje
    [1] =&gt; de
    [2] =&gt; marcado
    [3] =&gt; programación
)</pre>
</div>
    </div>
   </div>
  
  <p class="para">
   </p><div class="example" id="example-5058">
    <p><strong>Ejemplo #2 Dividir una cadena en caracteres</strong></p>
    <div class="example-contents">
<div class="annotation-interactive phpcode"><code><span style="color: #000000"><span style="color: #0000BB">&lt;?php<br>$str </span><span style="color: #007700">= </span><span style="color: #DD0000">'string'</span><span style="color: #007700">;<br></span><span style="color: #0000BB">$chars </span><span style="color: #007700">= </span><span style="color: #0000BB">preg_split</span><span style="color: #007700">(</span><span style="color: #DD0000">'//'</span><span style="color: #007700">, </span><span style="color: #0000BB">$str</span><span style="color: #007700">, -</span><span style="color: #0000BB">1</span><span style="color: #007700">, </span><span style="color: #0000BB">PREG_SPLIT_NO_EMPTY</span><span style="color: #007700">);<br></span><span style="color: #0000BB">print_r</span><span style="color: #007700">(</span><span style="color: #0000BB">$chars</span><span style="color: #007700">);<br></span><span style="color: #0000BB">?&gt;</span></span></code></div>
    </div>

    <div class="example-contents"><p>El ejemplo anterior mostrará:</p></div>
    <div class="example-contents screen">
<div class="annotation-interactive examplescode"><pre class="examplescode">Array
(
    [0] =&gt; s
    [1] =&gt; t
    [2] =&gt; r
    [3] =&gt; i
    [4] =&gt; n
    [5] =&gt; g
)</pre>
</div>
    </div>
   </div>
  
  <p class="para">
   </p><div class="example" id="example-5059">
    <p><strong>Ejemplo #3 Dividir una cadena y capturar las posiciones</strong></p>
    <div class="example-contents">
<div class="annotation-interactive phpcode"><code><span style="color: #000000"><span style="color: #0000BB">&lt;?php<br>$str </span><span style="color: #007700">= </span><span style="color: #DD0000">'lenguaje de marcado, programación'</span><span style="color: #007700">;<br></span><span style="color: #0000BB">$chars </span><span style="color: #007700">= </span><span style="color: #0000BB">preg_split</span><span style="color: #007700">(</span><span style="color: #DD0000">'/ /'</span><span style="color: #007700">, </span><span style="color: #0000BB">$str</span><span style="color: #007700">, -</span><span style="color: #0000BB">1</span><span style="color: #007700">, </span><span style="color: #0000BB">PREG_SPLIT_OFFSET_CAPTURE</span><span style="color: #007700">);<br></span><span style="color: #0000BB">print_r</span><span style="color: #007700">(</span><span style="color: #0000BB">$chars</span><span style="color: #007700">);<br></span><span style="color: #0000BB">?&gt;</span></span></code></div>
    </div>

    <div class="example-contents"><p>El ejemplo anterior mostrará:</p></div>
    <div class="example-contents screen">
<div class="annotation-interactive examplescode"><pre class="examplescode">Array
(
    [0] =&gt; Array
        (
            [0] =&gt; lenguaje
            [1] =&gt; 0
        )

    [1] =&gt; Array
        (
            [0] =&gt; de
            [1] =&gt; 8
        )

    [2] =&gt; Array
        (
            [0] =&gt; marcado,
            [1] =&gt; 12
        )

    [3] =&gt; Array
        (
            [0] =&gt; programación
            [1] =&gt; 22
        )

)</pre>
</div>
    </div>
   </div>
  
 </div>


 <div class="refsect1 notes" id="refsect1-function.preg-split-notes">
  <h3 class="title">Notas</h3>
  <div class="tip"><strong class="tip">Sugerencia</strong>
   <p class="para">
    Si no se necesita el poder de las expresiones regulares,
    pueden elegirse alternativas más rápidas (aunque más simples)
    como <span class="function"><a href="#function.explode" class="function">explode()</a></span> o <span class="function"><a href="#function.str-split" class="function">str_split()</a></span>.
   </p>
  </div>
  <div class="tip"><strong class="tip">Sugerencia</strong>
   <p class="para">
    Si la búsqueda de una coincidencia falla, se devuelve un array que contiene
    un solo elemento que contiene la cadena de entrada.
   </p>
  </div>
 </div>


 <div class="refsect1 seealso" id="refsect1-function.preg-split-seealso">
  <h3 class="title">Ver también</h3>
  <p class="para">
   </p><ul class="simplelist">
    <li><a href="#pcre.pattern" class="link">Patrones PCRE</a></li>
    <li><span class="function"><a href="#function.preg-quote" class="function" rel="rdfs-seeAlso">preg_quote()</a> - Protección de caracteres especiales de expresiones regulares</span></li>
    <li><span class="function"><a href="#function.explode" class="function" rel="rdfs-seeAlso">explode()</a> - Divide una string en segmentos</span></li>
    <li><span class="function"><a href="#function.preg-match" class="function" rel="rdfs-seeAlso">preg_match()</a> - Realiza una búsqueda de coincidencia con una expresión regular estándar</span></li>
    <li><span class="function"><a href="#function.preg-match-all" class="function" rel="rdfs-seeAlso">preg_match_all()</a> - Expresión regular global</span></li>
    <li><span class="function"><a href="#function.preg-replace" class="function" rel="rdfs-seeAlso">preg_replace()</a> - Buscar y reemplazar mediante expresión regular estándar</span></li>
    <li><span class="function"><a href="#function.preg-last-error" class="function" rel="rdfs-seeAlso">preg_last_error()</a> - Devuelve el código de error de la última expresión PCRE ejecutada</span></li>
   </ul>
  
 </div>


</div>
<hr>





<h2>Tabla de contenidos</h2><ul class="chunklist chunklist_reference"><li><a href="#function.preg-filter">preg_filter</a> — Búsqueda y reemplazo con una expresión regular</li><li><a href="#function.preg-grep">preg_grep</a> — Devuelve un array con los resultados de la búsqueda</li><li><a href="#function.preg-last-error">preg_last_error</a> — Devuelve el código de error de la última expresión PCRE ejecutada</li><li><a href="#function.preg-last-error-msg">preg_last_error_msg</a> — Devuelve el mensaje de error de la última ejecución de regex PCRE</li><li><a href="#function.preg-match">preg_match</a> — Realiza una búsqueda de coincidencia con una expresión regular estándar</li><li><a href="#function.preg-match-all">preg_match_all</a> — Expresión regular global</li><li><a href="#function.preg-quote">preg_quote</a> — Protección de caracteres especiales de expresiones regulares</li><li><a href="#function.preg-replace">preg_replace</a> — Buscar y reemplazar mediante expresión regular estándar</li><li><a href="#function.preg-replace-callback">preg_replace_callback</a> — Buscar y reemplazar mediante expresión regular estándar utilizando una función de retrollamada</li><li><a href="#function.preg-replace-callback-array">preg_replace_callback_array</a> — Realiza una búsqueda de coincidencia con una expresión regular y reemplaza mediante una función de devolución de llamada</li><li><a href="#function.preg-split">preg_split</a> — Divide una cadena mediante expresión regular</li></ul>
</div>

<hr>





<ul class="chunklist chunklist_book"><li><a href="#intro.pcre">Introducción</a></li><li><a href="#pcre.setup">Instalación/Configuración</a><ul class="chunklist chunklist_book chunklist_children"><li><a href="#pcre.installation">Instalación</a></li><li><a href="#pcre.configuration">Configuración en tiempo de ejecución</a></li></ul></li><li><a href="#pcre.constants">Constantes predefinidas</a></li><li><a href="#pcre.examples">Ejemplos</a></li><li><a href="#pcre.pattern">Patrones PCRE</a><ul class="chunklist chunklist_book chunklist_children"><li><a href="#reference.pcre.pattern.syntax">Sintaxis de expresiones regulares PCRE</a> — Sintaxis de patrones</li><li><a href="#reference.pcre.pattern.modifiers">Opciones disponibles para las expresiones regulares</a> — Opciones de búsqueda</li><li><a href="#reference.pcre.pattern.differences">Diferencias con Perl</a></li></ul></li><li><a href="#ref.pcre">Funciones de PCRE</a><ul class="chunklist chunklist_book chunklist_children"><li><a href="#function.preg-filter">preg_filter</a> — Búsqueda y reemplazo con una expresión regular</li><li><a href="#function.preg-grep">preg_grep</a> — Devuelve un array con los resultados de la búsqueda</li><li><a href="#function.preg-last-error">preg_last_error</a> — Devuelve el código de error de la última expresión PCRE ejecutada</li><li><a href="#function.preg-last-error-msg">preg_last_error_msg</a> — Devuelve el mensaje de error de la última ejecución de regex PCRE</li><li><a href="#function.preg-match">preg_match</a> — Realiza una búsqueda de coincidencia con una expresión regular estándar</li><li><a href="#function.preg-match-all">preg_match_all</a> — Expresión regular global</li><li><a href="#function.preg-quote">preg_quote</a> — Protección de caracteres especiales de expresiones regulares</li><li><a href="#function.preg-replace">preg_replace</a> — Buscar y reemplazar mediante expresión regular estándar</li><li><a href="#function.preg-replace-callback">preg_replace_callback</a> — Buscar y reemplazar mediante expresión regular estándar utilizando una función de retrollamada</li><li><a href="#function.preg-replace-callback-array">preg_replace_callback_array</a> — Realiza una búsqueda de coincidencia con una expresión regular y reemplaza mediante una función de devolución de llamada</li><li><a href="#function.preg-split">preg_split</a> — Divide una cadena mediante expresión regular</li></ul></li></ul></div>